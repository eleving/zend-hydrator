{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-hydrator Repository abandoned 2019-12-31 This repository has moved to laminas/laminas-hydrator . Zend\\Hydrator provides utilities for mapping arrays to objects, and vice versa, including facilities for filtering which data is mapped as well as providing mechanisms for mapping nested structures. File issues at https://github.com/zendframework/zend-hydrator/issues Documentation is at https://docs.zendframework.com/zend-hydrator/","title":"Home"},{"location":"#zend-hydrator","text":"","title":"zend-hydrator"},{"location":"#repository-abandoned-2019-12-31","text":"This repository has moved to laminas/laminas-hydrator . Zend\\Hydrator provides utilities for mapping arrays to objects, and vice versa, including facilities for filtering which data is mapped as well as providing mechanisms for mapping nested structures. File issues at https://github.com/zendframework/zend-hydrator/issues Documentation is at https://docs.zendframework.com/zend-hydrator/","title":"Repository abandoned 2019-12-31"},{"location":"aggregate/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-hydrator/v2/aggregate/'; });","title":"_aggregates"},{"location":"filter/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-hydrator/v2/filter/'; });","title":"_filters"},{"location":"quick-start/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-hydrator/v2/quick-start/'; });","title":"_quick_start"},{"location":"strategy/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-hydrator/v2/strategy/'; });","title":"_strategies"},{"location":"naming-strategy/composite-naming-strategy/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-hydrator/v2/naming-strategy/composite-naming-strategy/'; });","title":"_naming_strategies-composite"},{"location":"naming-strategy/identity-naming-strategy/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-hydrator/v2/naming-strategy/identity-naming-strategy/'; });","title":"_naming_strategies-identity"},{"location":"naming-strategy/map-naming-strategy/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-hydrator/v2/naming-strategy/map-naming-strategy/'; });","title":"_naming_strategies-mapping"},{"location":"naming-strategy/underscore-naming-strategy/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-hydrator/v2/naming-strategy/underscore-naming-strategy/'; });","title":"_naming_strategies-underscore_mapping"},{"location":"v2/aggregate/","text":"AggregateHydrator Zend\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Zend\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps. Installation requirements The AggregateHydrator depends on the zend-eventmanager component, so be sure to have it installed before getting started: $ composer require zendframework/zend-eventmanager Basic usage A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Zend\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator->add(new My\\BlogPostHydrator()); $hydrator->add(new My\\UserAwareObjectHydrator()); $hydrator->add(new My\\TimestampedObjectHydrator()); $hydrator->add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator->extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator->hydrate($data, $blogPost); Hydrator priorities AggregateHydrator::add has a second optional argument, $priority . If you have two or more hydrators that conflict with each other for same data keys, you may decide which one to execute first or last by passing a higher or lower integer priority, respectively, to this argument. In order to work with this logic, each of the hydrators that are attached should ignore any unknown object type passed in: namespace My; use Zend\\Hydrator\\HydratorInterface class BlogPostHydrator implements HydratorInterface { public function hydrate($data, $object) { if (! $object instanceof BlogPost) { return $object; } // ... continue hydration ... } public function extract($object) { if (! $object instanceof BlogPost) { return array(); } // ... continue extraction ... } } Advanced use cases Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Zend\\Hydrator\\Aggregate\\AggregateHydrator; use Zend\\Hydrator\\Aggregate\\ExtractEvent; use Zend\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator->add(new My\\BlogPostHydrator()); $hydrator->add(new My\\UserAwareObjectHydrator()); $hydrator->add(new My\\TimestampedObjectHydrator()); $hydrator->add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event->getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache->hasItem($object->getId())) { $event->setExtractedData($cache->getItem($object->getId())); $event->stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event->getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache->setItem($object->getId(), $event->getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator->getEventManager(); $eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator->extract($blogPost) operation will be cached.","title":"Aggregates"},{"location":"v2/aggregate/#aggregatehydrator","text":"Zend\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Zend\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps.","title":"AggregateHydrator"},{"location":"v2/aggregate/#installation-requirements","text":"The AggregateHydrator depends on the zend-eventmanager component, so be sure to have it installed before getting started: $ composer require zendframework/zend-eventmanager","title":"Installation requirements"},{"location":"v2/aggregate/#basic-usage","text":"A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Zend\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator->add(new My\\BlogPostHydrator()); $hydrator->add(new My\\UserAwareObjectHydrator()); $hydrator->add(new My\\TimestampedObjectHydrator()); $hydrator->add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator->extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator->hydrate($data, $blogPost);","title":"Basic usage"},{"location":"v2/aggregate/#advanced-use-cases","text":"Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Zend\\Hydrator\\Aggregate\\AggregateHydrator; use Zend\\Hydrator\\Aggregate\\ExtractEvent; use Zend\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator->add(new My\\BlogPostHydrator()); $hydrator->add(new My\\UserAwareObjectHydrator()); $hydrator->add(new My\\TimestampedObjectHydrator()); $hydrator->add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event->getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache->hasItem($object->getId())) { $event->setExtractedData($cache->getItem($object->getId())); $event->stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event->getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache->setItem($object->getId(), $event->getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator->getEventManager(); $eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator->extract($blogPost) operation will be cached.","title":"Advanced use cases"},{"location":"v2/filter/","text":"Zend\\Hydrator\\Filter Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Zend\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter * does not match * * @param string $property The name of the property * @return bool */ public function filter($property); } If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again. Filter implementations Zend\\Hydrator\\Filter\\GetFilter This filter is used in the ClassMethods hydrator to decide which getters will be extracted. It checks if the key to extract starts with get or the object contains a method beginning with get (e.g., Zend\\Foo\\Bar::getFoo ). Zend\\Hydrator\\Filter\\HasFilter This filter is used in the ClassMethods hydrator to decide which has methods will be extracted. It checks if the key to extract begins with has or the object contains a method beginning with has (e.g., Zend\\Foo\\Bar::hasFoo ). Zend\\Hydrator\\Filter\\IsFilter This filter is used in the ClassMethods hydrator to decide which is methods will be extracted. It checks if the key to extract begins with is or the object contains a method beginning with is (e.g., Zend\\Foo\\Bar::isFoo ). Zend\\Hydrator\\Filter\\MethodMatchFilter This filter allows you to omit methods during extraction that match the condition defined in the composite. The name of the method is specified in the constructor of this filter; the second parameter decides whether to use white or blacklisting to decide (whitelisting retains only the matching method, blacklist omits any matching method). The default is blacklisting - pass false to change the behavior. Zend\\Hydrator\\Filter\\NumberOfParameterFilter This filter is used in the ClassMethods hydrator to check the number of parameters. By convention, the get , has and is methods do not get any parameters - but it may happen. You can add your own number of required parameters, simply add the number to the constructor. The default value is 0. If the method has more or fewer parameters than what the filter accepts, it will be omitted. Remove filters If you want to tell e.g. the ClassMethods hydrator, to not extract methods that start with is , remove the related filter: $hydrator = new ClassMethods(false); $hydrator->removeFilter('is'); After performing the above, the key/value pairs for is methods will not end up in your extracted array anymore. The filters can be used in any hydrator, but the ClassMethods hydrator is the only one, that has pre-registered filters: $this->filterComposite->addFilter('is', new IsFilter()); $this->filterComposite->addFilter('has', new HasFilter()); $this->filterComposite->addFilter('get', new GetFilter()); $this->filterComposite->addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND ); If these are not appropriate for your object, you can unregister them as shown in the previous example. Add filters You can add filters to any hydrator that extends the AbstractHydrator . Filters can either implement FilterInterface , or simply be PHP callables: $hydrator->addFilter('len', function($property) { if (strlen($property) !== 3) { return false; } return true; }); By default, every filter you add will be added with a conditional or . If you want to add it with and (as the NumberOfParameterFilter that is added to the ClassMethods hydrator by default), provide the conditon as the third argument to addFilter : $hydrator->addFilter('len', function($property) { if (strlen($property) !== 3) { return false; } return true; }, FilterComposite::CONDITION_AND); One common use case for filters is to omit getters for values that you do not want to represent, such as a service manager instance: $hydrator->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); The example above will exclude the getServiceManager() method and the servicemanager key from extraction, even if the get filter wants to add it. Use FilterComposite for complex filters FilterComposite implements FilterInterface as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different composites with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter: Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR At the given level of the composite, at least one filter in that condition block has to return true to extract the value. Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_AND At the given level of the composite, all filters in that condition block must return true to extract the value. FilterComposite Examples This composition will have a similar logic as the if below: $composite = new FilterComposite(); $composite->addFilter('one', $condition1); $composite->addFilter('two', $condition2); $composite->addFilter('three', $condition3); $composite->addFilter('four', $condition4, FilterComposite::CONDITION_AND); $composite->addFilter('five', $condition5, FilterComposite::CONDITION_AND); // This is what's happening internally if ( ($condition1 || $condition2 || $condition3 ) && ($condition4 && $condition5 ) ) { //do extraction } If you only have one condition (e.g., only an and or or ) block, the other one will be completely ignored. A bit more complex filter can look like this: $composite = new FilterComposite(); $composite->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $composite->addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $hydrator->addFilter('excludes', $composite, FilterComposite::CONDITION_AND); // Internal if (( // default composite inside the hydrator ($getFilter || $hasFilter || $isFilter ) && ( $numberOfParameterFilter ) ) && ( // new composite, added to the one above $serviceManagerFilter && $eventManagerFilter ) ) { // do extraction } If you perform this on the ClassMethods hydrator, all getters will get extracted, except for getServiceManager() and getEventManager() . Using the provider interface FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Zend\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Zend\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite->addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite->addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethods(false); $extractedArray = $hydrator->extract(new Foo()); $extractedArray will only have 'foo' => 'foo'; all other values are excluded from extraction. Note All pre-registered filters from the ClassMethods hydrator are ignored when this interface is used.","title":"Filters"},{"location":"v2/filter/#zend92hydrator92filter","text":"Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Zend\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter * does not match * * @param string $property The name of the property * @return bool */ public function filter($property); } If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again.","title":"Zend\\Hydrator\\Filter"},{"location":"v2/filter/#filter-implementations","text":"","title":"Filter implementations"},{"location":"v2/filter/#remove-filters","text":"If you want to tell e.g. the ClassMethods hydrator, to not extract methods that start with is , remove the related filter: $hydrator = new ClassMethods(false); $hydrator->removeFilter('is'); After performing the above, the key/value pairs for is methods will not end up in your extracted array anymore. The filters can be used in any hydrator, but the ClassMethods hydrator is the only one, that has pre-registered filters: $this->filterComposite->addFilter('is', new IsFilter()); $this->filterComposite->addFilter('has', new HasFilter()); $this->filterComposite->addFilter('get', new GetFilter()); $this->filterComposite->addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND ); If these are not appropriate for your object, you can unregister them as shown in the previous example.","title":"Remove filters"},{"location":"v2/filter/#add-filters","text":"You can add filters to any hydrator that extends the AbstractHydrator . Filters can either implement FilterInterface , or simply be PHP callables: $hydrator->addFilter('len', function($property) { if (strlen($property) !== 3) { return false; } return true; }); By default, every filter you add will be added with a conditional or . If you want to add it with and (as the NumberOfParameterFilter that is added to the ClassMethods hydrator by default), provide the conditon as the third argument to addFilter : $hydrator->addFilter('len', function($property) { if (strlen($property) !== 3) { return false; } return true; }, FilterComposite::CONDITION_AND); One common use case for filters is to omit getters for values that you do not want to represent, such as a service manager instance: $hydrator->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); The example above will exclude the getServiceManager() method and the servicemanager key from extraction, even if the get filter wants to add it.","title":"Add filters"},{"location":"v2/filter/#use-filtercomposite-for-complex-filters","text":"FilterComposite implements FilterInterface as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different composites with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter:","title":"Use FilterComposite for complex filters"},{"location":"v2/filter/#using-the-provider-interface","text":"FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Zend\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Zend\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite->addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite->addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethods(false); $extractedArray = $hydrator->extract(new Foo()); $extractedArray will only have 'foo' => 'foo'; all other values are excluded from extraction.","title":"Using the provider interface"},{"location":"v2/quick-start/","text":"zend-hydrator Hydration is the act of populating an object from a set of data. zend-hydrator is a simple component to provide mechanisms both for hydrating objects, as well as extracting data sets from them. The component consists of interfaces, and several implementations for common use cases. Base Interfaces ExtractionInterface namespace Zend\\Hydrator; interface ExtractionInterface { / * Extract values from an object * * @param object $object * @return array */ public function extract($object); } HydrationInterface namespace Zend\\Hydrator; interface HydrationInterface { / * Hydrate $object with the provided $data. * * @param array $data * @param object $object * @return object */ public function hydrate(array $data, $object); } HydratorInterface namespace Zend\\Hydrator; interface HydratorInterface extends ExtractionInterface, HydrationInterface { } Usage Usage involves instantiating the hydrator, and then passing information to it. use Zend\\Hydrator; $hydrator = new Hydrator\\ArraySerializable(); // To hydrate an object from values in an array: $object = $hydrator->hydrate($data, new ArrayObject()); // or, going the other way and extracting the values from an object as an array: $data = $hydrator->extract($object); Available Implementations Zend\\Hydrator\\ArraySerializable Follows the definition of ArrayObject . Objects must implement either the exchangeArray() or populate() methods to support hydration, and the getArrayCopy() method to support extraction. Zend\\Hydrator\\ClassMethods Any data key matching a setter method will be called in order to hydrate; any method matching a getter method will be called for extraction. Zend\\Hydrator\\DelegatingHydrator Composes a hydrator locator, and will delegate hydrate() and extract() calls to the appropriate one based upon the class name of the object being operated on. // Instantiate each hydrator you wish to delegate to $albumHydrator = new Zend\\Hydrator\\ClassMethods; $artistHydrator = new Zend\\Hydrator\\ClassMethods; // Map the entity class name to the hydrator using the HydratorPluginManager. // In this case we have two entity classes, \"Album\" and \"Artist\". $hydrators = new Zend\\Hydrator\\HydratorPluginManager; $hydrators->setService('Album', $albumHydrator); $hydrators->setService('Artist', $artistHydrator); // Create the DelegatingHydrator and tell it to use our configured hydrator locator $delegating = new Zend\\Hydrator\\DelegatingHydrator($hydrators); // Now we can use $delegating to hydrate or extract any supported object $array = $delegating->extract(new Artist); $artist = $delegating->hydrate($data, new Artist); Zend\\Hydrator\\ObjectProperty Any data key matching a publicly accessible property will be hydrated; any public properties will be used for extraction. Zend\\Hydrator\\Reflection Similar to the ObjectProperty hydrator, but uses PHP's reflection API to hydrate or extract properties of any visibility. Any data key matching an existing property will be hydrated; any existing properties will be used for extraction.","title":"Quick Start"},{"location":"v2/quick-start/#zend-hydrator","text":"Hydration is the act of populating an object from a set of data. zend-hydrator is a simple component to provide mechanisms both for hydrating objects, as well as extracting data sets from them. The component consists of interfaces, and several implementations for common use cases.","title":"zend-hydrator"},{"location":"v2/quick-start/#base-interfaces","text":"","title":"Base Interfaces"},{"location":"v2/quick-start/#usage","text":"Usage involves instantiating the hydrator, and then passing information to it. use Zend\\Hydrator; $hydrator = new Hydrator\\ArraySerializable(); // To hydrate an object from values in an array: $object = $hydrator->hydrate($data, new ArrayObject()); // or, going the other way and extracting the values from an object as an array: $data = $hydrator->extract($object);","title":"Usage"},{"location":"v2/quick-start/#available-implementations","text":"","title":"Available Implementations"},{"location":"v2/strategy/","text":"Zend\\Hydrator\\Strategy You can add Zend\\Hydrator\\Strategy\\StrategyInterface to any of the hydrators (except if it extends Zend\\Hydrator\\AbstractHydrator or implements Zend\\Hydrator\\HydratorInterface and Zend\\Hydrator\\Strategy\\StrategyEnabledInterface ) to manipulate the way how they behave on extract() and hydrate() for specific key / value pairs. This is the interface that needs to be implemented: namespace Zend\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @return mixed Returns the value that should be extracted. */ public function extract($value); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value); } This interface is similar to Zend\\Hydrator\\HydratorInterface ; the reason is that strategies provide a proxy implementation for hydrate() and extract() . Adding strategies to the hydrators To allow strategies within your hydrator, Zend\\Hydrator\\Strategy\\StrategyEnabledInterface provides the following methods: namespace Zend\\Hydrator; use Zend\\Hydrator\\Strategy\\StrategyInterface; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. * * @param string $name The name of the strategy to register. * @param StrategyInterface $strategy The strategy to register. * @return HydratorInterface */ public function addStrategy($name, StrategyInterface $strategy); /** * Gets the strategy with the given name. * * @param string $name The name of the strategy to get. * @return StrategyInterface */ public function getStrategy($name); /** * Checks if the strategy with the given name exists. * * @param string $name The name of the strategy to check for. * @return bool */ public function hasStrategy($name); /** * Removes the strategy with the given name. * * @param string $name The name of the strategy to remove. * @return HydratorInterface */ public function removeStrategy($name); } Every hydrator shipped by default provides this functionality; AbstractHydrator fully implements it as well. As such, if you want to use this functionality in your own hydrators, you should extend AbstractHydrator . Available implementations Zend\\Hydrator\\Strategy\\BooleanStrategy This strategy converts values into Booleans and vice versa. It expects two arguments at the constructor, which are used to define value maps for true and false . Zend\\Hydrator\\Strategy\\ClosureStrategy This is a strategy that allows you to pass in options for: hydrate , a callback to be called when hydrating a value, and extract , a callback to be called when extracting a value. Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy DateTimeFormatterStrategy provides bidirectional conversion between strings and DateTime instances. The input and output formats can be provided as constructor arguments. As of version 2.4.1, this strategy now allows DateTime formats that use ! to prepend the format, or | or + to append it; these ensure that, during hydration, the new DateTime instance created will set the time element accordingly. As a specific example, Y-m-d| will drop the time component, ensuring comparisons are based on a midnight time value. Zend\\Hydrator\\Strategy\\DefaultStrategy The DefaultStrategy simply proxies everything through, without performing any conversion of values. Zend\\Hydrator\\Strategy\\ExplodeStrategy This strategy is a wrapper around PHP's implode() and explode() functions. The delimiter and a limit can be provided to the constructor; the limit will only be used for extract operations. Zend\\Hydrator\\Strategy\\SerializableStrategy SerializableStrategy provides the functionality backing Zend\\Hydrator\\ArraySerializable . You can use it with custom implementations for Zend\\Serializer\\Adapter\\AdapterInterface if you want to as well. Zend\\Hydrator\\Strategy\\StrategyChain This strategy takes an array of StrategyInterface instances and iterates over them when performing extract() and hydrate() operations. Each operates on the return value of the previous, allowing complex operations based on smaller, single-purpose strategies. Writing custom strategies The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this->foo; } public function setFoo($foo) { $this->foo = $foo; } public function getBar() { return $this->bar; } public function setBar($bar) { $this->bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo->setFoo('bar'); $foo->setBar('foo'); $hydrator = new ClassMethods(); $hydrator->addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator->extract($foo); // array(2) { // [\"foo\"]=> // string(3) \"one\" // [\"bar\"]=> // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator->hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=> // string(3) \"bar\" // [\"bar\":protected]=> // string(3) \"foo\" // }","title":"Strategies"},{"location":"v2/strategy/#zend92hydrator92strategy","text":"You can add Zend\\Hydrator\\Strategy\\StrategyInterface to any of the hydrators (except if it extends Zend\\Hydrator\\AbstractHydrator or implements Zend\\Hydrator\\HydratorInterface and Zend\\Hydrator\\Strategy\\StrategyEnabledInterface ) to manipulate the way how they behave on extract() and hydrate() for specific key / value pairs. This is the interface that needs to be implemented: namespace Zend\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @return mixed Returns the value that should be extracted. */ public function extract($value); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value); } This interface is similar to Zend\\Hydrator\\HydratorInterface ; the reason is that strategies provide a proxy implementation for hydrate() and extract() .","title":"Zend\\Hydrator\\Strategy"},{"location":"v2/strategy/#adding-strategies-to-the-hydrators","text":"To allow strategies within your hydrator, Zend\\Hydrator\\Strategy\\StrategyEnabledInterface provides the following methods: namespace Zend\\Hydrator; use Zend\\Hydrator\\Strategy\\StrategyInterface; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. * * @param string $name The name of the strategy to register. * @param StrategyInterface $strategy The strategy to register. * @return HydratorInterface */ public function addStrategy($name, StrategyInterface $strategy); /** * Gets the strategy with the given name. * * @param string $name The name of the strategy to get. * @return StrategyInterface */ public function getStrategy($name); /** * Checks if the strategy with the given name exists. * * @param string $name The name of the strategy to check for. * @return bool */ public function hasStrategy($name); /** * Removes the strategy with the given name. * * @param string $name The name of the strategy to remove. * @return HydratorInterface */ public function removeStrategy($name); } Every hydrator shipped by default provides this functionality; AbstractHydrator fully implements it as well. As such, if you want to use this functionality in your own hydrators, you should extend AbstractHydrator .","title":"Adding strategies to the hydrators"},{"location":"v2/strategy/#available-implementations","text":"","title":"Available implementations"},{"location":"v2/strategy/#writing-custom-strategies","text":"The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this->foo; } public function setFoo($foo) { $this->foo = $foo; } public function getBar() { return $this->bar; } public function setBar($bar) { $this->bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo->setFoo('bar'); $foo->setBar('foo'); $hydrator = new ClassMethods(); $hydrator->addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator->extract($foo); // array(2) { // [\"foo\"]=> // string(3) \"one\" // [\"bar\"]=> // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator->hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=> // string(3) \"bar\" // [\"bar\":protected]=> // string(3) \"foo\" // }","title":"Writing custom strategies"},{"location":"v2/naming-strategy/composite-naming-strategy/","text":"CompositeNamingStrategy Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction. Basic Usage When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar' ]); $underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' => $mapStrategy, 'barBat' => $underscoreNamingStrategy, ]); $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $foo->bar = 123; $foo->barBat = 42; print_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar' ]); $underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo => bar mapping 'bar' => $mapStrategy, 'foo' => $mapStrategy, // Define both directions for the barBat => bar_bat mapping 'barBat' => $underscoreNamingStrategy, 'bar_bat' => $underscoreNamingStrategy, ]); $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $foo->bar = 123; $foo->barBat = 42; $array = $hydrator->extract($foo); print_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 ) print_r($array); // Array ( [foo] => 123 [bar_bat] => 42 ) $foo2 = new Foo(); $hydrator->hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )","title":"Composite"},{"location":"v2/naming-strategy/composite-naming-strategy/#compositenamingstrategy","text":"Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction.","title":"CompositeNamingStrategy"},{"location":"v2/naming-strategy/composite-naming-strategy/#basic-usage","text":"When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar' ]); $underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' => $mapStrategy, 'barBat' => $underscoreNamingStrategy, ]); $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $foo->bar = 123; $foo->barBat = 42; print_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar' ]); $underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo => bar mapping 'bar' => $mapStrategy, 'foo' => $mapStrategy, // Define both directions for the barBat => bar_bat mapping 'barBat' => $underscoreNamingStrategy, 'bar_bat' => $underscoreNamingStrategy, ]); $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $foo->bar = 123; $foo->barBat = 42; $array = $hydrator->extract($foo); print_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 ) print_r($array); // Array ( [foo] => 123 [bar_bat] => 42 ) $foo2 = new Foo(); $hydrator->hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )","title":"Basic Usage"},{"location":"v2/naming-strategy/identity-naming-strategy/","text":"IdentityNamingStrategy Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction. Basic Usage $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy->hydrate('foo'); // outputs: foo echo $namingStrategy->extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator->hydrate(array('foo' => 123), $foo); print_r($foo); // Foo Object ( [foo] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 )","title":"Identity"},{"location":"v2/naming-strategy/identity-naming-strategy/#identitynamingstrategy","text":"Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction.","title":"IdentityNamingStrategy"},{"location":"v2/naming-strategy/identity-naming-strategy/#basic-usage","text":"$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy->hydrate('foo'); // outputs: foo echo $namingStrategy->extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator->hydrate(array('foo' => 123), $foo); print_r($foo); // Foo Object ( [foo] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 )","title":"Basic Usage"},{"location":"v2/naming-strategy/map-naming-strategy/","text":"MapNamingStrategy Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use when hydrating and extracting; the map will translate the key based on the direction. Basic Usage $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy(array( 'foo' => 'bar', 'baz' => 'bash' )); echo $namingStrategy->hydrate('foo'); // outputs: bar echo $namingStrategy->hydrate('baz'); // outputs: bash echo $namingStrategy->extract('bar'); // outputs: foo echo $namingStrategy->extract('bash'); // outputs: baz This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar', 'baz' => 'bash' ]); $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator->hydrate(['foo' => 123], $foo); print_r($foo); // Foo Object ( [bar] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 )","title":"Mapping"},{"location":"v2/naming-strategy/map-naming-strategy/#mapnamingstrategy","text":"Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use when hydrating and extracting; the map will translate the key based on the direction.","title":"MapNamingStrategy"},{"location":"v2/naming-strategy/map-naming-strategy/#basic-usage","text":"$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy(array( 'foo' => 'bar', 'baz' => 'bash' )); echo $namingStrategy->hydrate('foo'); // outputs: bar echo $namingStrategy->hydrate('baz'); // outputs: bash echo $namingStrategy->extract('bar'); // outputs: foo echo $namingStrategy->extract('bash'); // outputs: baz This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar', 'baz' => 'bash' ]); $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator->hydrate(['foo' => 123], $foo); print_r($foo); // Foo Object ( [bar] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 )","title":"Basic Usage"},{"location":"v2/naming-strategy/underscore-naming-strategy/","text":"UnderscoreNamingStrategy Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa. Basic Usage $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy->extract('foo_bar'); // outputs: foo_bar echo $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy->extract('FooBar'); // outputs: foo_bar echo $namingStrategy->hydrate('fooBar'); // outputs: fooBar echo $namingStrategy->hydrate('FooBar'); // outputs: fooBar echo $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator->hydrate(['foo_bar' => 123], $foo); print_r($foo); // Foo Object ( [fooBar] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )","title":"Underscore Mapping"},{"location":"v2/naming-strategy/underscore-naming-strategy/#underscorenamingstrategy","text":"Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa.","title":"UnderscoreNamingStrategy"},{"location":"v2/naming-strategy/underscore-naming-strategy/#basic-usage","text":"$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy->extract('foo_bar'); // outputs: foo_bar echo $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy->extract('FooBar'); // outputs: foo_bar echo $namingStrategy->hydrate('fooBar'); // outputs: fooBar echo $namingStrategy->hydrate('FooBar'); // outputs: fooBar echo $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Zend\\Hydrator\\ObjectProperty(); $hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator->hydrate(['foo_bar' => 123], $foo); print_r($foo); // Foo Object ( [fooBar] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )","title":"Basic Usage"},{"location":"v3/aggregate/","text":"AggregateHydrator Zend\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Zend\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps. Installation requirements The AggregateHydrator depends on the zend-eventmanager component, so be sure to have it installed before getting started: $ composer require zendframework/zend-eventmanager Basic usage A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Zend\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator->add(new My\\BlogPostHydrator()); $hydrator->add(new My\\UserAwareObjectHydrator()); $hydrator->add(new My\\TimestampedObjectHydrator()); $hydrator->add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator->extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator->hydrate($data, $blogPost); Hydrator priorities AggregateHydrator::add has a second optional argument, $priority . If you have two or more hydrators that conflict with each other for same data keys, you may decide which one to execute first or last by passing a higher or lower integer priority, respectively, to this argument. In order to work with this logic, each of the hydrators that are attached should ignore any unknown object type passed in: namespace My; use Zend\\Hydrator\\HydratorInterface class BlogPostHydrator implements HydratorInterface { public function hydrate($data, $object) { if (! $object instanceof BlogPost) { return $object; } // ... continue hydration ... } public function extract($object) { if (! $object instanceof BlogPost) { return array(); } // ... continue extraction ... } } Advanced use cases Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Zend\\Hydrator\\Aggregate\\AggregateHydrator; use Zend\\Hydrator\\Aggregate\\ExtractEvent; use Zend\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator->add(new My\\BlogPostHydrator()); $hydrator->add(new My\\UserAwareObjectHydrator()); $hydrator->add(new My\\TimestampedObjectHydrator()); $hydrator->add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event->getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache->hasItem($object->getId())) { $event->setExtractedData($cache->getItem($object->getId())); $event->stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event->getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache->setItem($object->getId(), $event->getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator->getEventManager(); $eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator->extract($blogPost) operation will be cached.","title":"Aggregates"},{"location":"v3/aggregate/#aggregatehydrator","text":"Zend\\Hydrator\\Aggregate\\AggregateHydrator is an implementation of Zend\\Hydrator\\HydratorInterface that composes multiple hydrators via event listeners. You typically want to use an aggregate hydrator when you want to hydrate or extract data from complex objects that implement multiple interfaces, and therefore need multiple hydrators to handle that in subsequent steps.","title":"AggregateHydrator"},{"location":"v3/aggregate/#installation-requirements","text":"The AggregateHydrator depends on the zend-eventmanager component, so be sure to have it installed before getting started: $ composer require zendframework/zend-eventmanager","title":"Installation requirements"},{"location":"v3/aggregate/#basic-usage","text":"A simple use case may be hydrating a BlogPost object, which contains data for the user that created it, the time it was created, the current publishing status, etc: use Zend\\Hydrator\\Aggregate\\AggregateHydrator; $hydrator = new AggregateHydrator(); // attach the various hydrators capable of handling simpler interfaces $hydrator->add(new My\\BlogPostHydrator()); $hydrator->add(new My\\UserAwareObjectHydrator()); $hydrator->add(new My\\TimestampedObjectHydrator()); $hydrator->add(new My\\PublishableObjectHydrator()); // ... // Now retrieve the BlogPost object // ... // you can now extract complex data from a blogpost $data = $hydrator->extract($blogPost); // or you can fill the object with complex data $blogPost = $hydrator->hydrate($data, $blogPost);","title":"Basic usage"},{"location":"v3/aggregate/#advanced-use-cases","text":"Since the AggregateHydrator is event-driven, you can use the EventManager API to tweak its behaviour. Common use cases include: Removal of hydrated data keys (passwords/confidential information) depending on business rules. Caching of the hydration/extraction process. Transformations on extracted data, for compatibility with third-party APIs. In the following example, a cache listener is introduced to speed up hydration, which can be very useful when the same data is requested multiple times: use Zend\\Hydrator\\Aggregate\\AggregateHydrator; use Zend\\Hydrator\\Aggregate\\ExtractEvent; use Zend\\Cache\\Storage\\Adapter\\Memory; $hydrator = new AggregateHydrator(); // Attach the various hydrators: $hydrator->add(new My\\BlogPostHydrator()); $hydrator->add(new My\\UserAwareObjectHydrator()); $hydrator->add(new My\\TimestampedObjectHydrator()); $hydrator->add(new My\\PublishableObjectHydrator()); // ... $cache = new Memory(); $cacheReadListener = function (ExtractEvent $event) use ($cache) { $object = $event->getExtractionObject(); if (! $object instanceof BlogPost) { return; } if ($cache->hasItem($object->getId())) { $event->setExtractedData($cache->getItem($object->getId())); $event->stopPropagation(); } }; $cacheWriteListener = function (ExtractEvent $event) use ($cache) { $object = $event->getExtractionObject(); if (! $object instanceof BlogPost) { return; } $cache->setItem($object->getId(), $event->getExtractedData()); }; // Attaching a high priority listener executed before extraction logic: $eventManager = $hydrator->getEventManager(); $eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000); // Attaching a low priority listener executed after extraction logic: $eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000); With an aggregate hydrator configured in this way, any $hydrator->extract($blogPost) operation will be cached.","title":"Advanced use cases"},{"location":"v3/filter/","text":"Zend\\Hydrator\\Filter Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Zend\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter does not match. */ public function filter(string $property) : bool; } ``` If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again. ## Filter implementations ### Zend\\\\Hydrator\\\\Filter\\\\GetFilter This filter is used in the `ClassMethodsHydrator` to decide which getters will be extracted. It checks if the key to extract starts with `get` or the object contains a method beginning with `get` (e.g., `Zend\\Foo\\Bar::getFoo`). ### Zend\\\\Hydrator\\\\Filter\\\\HasFilter This filter is used in the `ClassMethodsHydrator` to decide which `has` methods will be extracted. It checks if the key to extract begins with `has` or the object contains a method beginning with `has` (e.g., `Zend\\Foo\\Bar::hasFoo`). ### Zend\\\\Hydrator\\\\Filter\\\\IsFilter This filter is used in the `ClassMethodsHydrator` to decide which `is` methods will be extracted. It checks if the key to extract begins with `is` or the object contains a method beginning with `is` (e.g., `Zend\\Foo\\Bar::isFoo`). ### Zend\\\\Hydrator\\\\Filter\\\\MethodMatchFilter This filter allows you to omit methods during extraction that match the condition defined in the composite. The name of the method is specified in the constructor of this filter; the second parameter decides whether to use white or blacklisting to decide (whitelisting retains only the matching method, blacklist omits any matching method). The default is blacklisting - pass `false` to change the behavior. ### Zend\\\\Hydrator\\\\Filter\\\\NumberOfParameterFilter This filter is used in the `ClassMethodsHydrator` to check the number of parameters. By convention, the `get`, `has` and `is` methods do not get any parameters - but it may happen. You can add your own number of required parameters, simply add the number to the constructor. The default value is 0. If the method has more or fewer parameters than what the filter accepts, it will be omitted. ## Use FilterComposite for complex filters `FilterComposite` implements `FilterInterface` as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different filters with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter: ### Zend\\\\Hydrator\\\\Filter\\\\FilterComposite::CONDITION\\_OR At the given level of the composite, at least one filter set using `CONDITION_OR` must return true to extract the value. ### Zend\\\\Hydrator\\\\Filter\\\\FilterComposite::CONDITION\\_AND At the given level of the composite, **all** filters set using `CONDITION_AND` must return true to extract the value. ### FilterComposite Examples To illustrate how conditions apply when composing filters, consider the following set of filters: ```php $composite = new FilterComposite(); $composite->addFilter('one', $condition1); $composite->addFilter('two', $condition2); $composite->addFilter('three', $condition3); $composite->addFilter('four', $condition4, FilterComposite::CONDITION_AND); $composite->addFilter('five', $condition5, FilterComposite::CONDITION_AND); ``` The above is roughly equivalent to the following conditional: // This is what's happening internally if ( ($condition1 || $condition2 || $condition3 ) && ($condition4 && $condition5 ) ) { // do extraction } If you only have one condition block (e.g., only `AND` or `OR` filters), the other condition type will be completely ignored. A bit more complex filter can look like this: ```php $composite = new FilterComposite(); $composite->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $composite->addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $hydrator->addFilter('excludes', $composite, FilterComposite::CONDITION_AND); // Internal if (( // default composite inside the ClassMethodsHydrator: ($getFilter || $hasFilter || $isFilter ) && ( $numberOfParameterFilter ) ) && ( // new composite, added to the one above $serviceManagerFilter && $eventManagerFilter ) ) { // do extraction } If you perform this on the ClassMethodsHydrator , all getters will get extracted, except for getServiceManager() and getEventManager() . Using the provider interface Zend\\Hydrator\\Filter\\FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Zend\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Zend\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite->addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite->addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethodsHydrator(false); $extractedArray = $hydrator->extract(new Foo()); $extractedArray will only have 'foo' => 'foo'; all other values are excluded from extraction. Note All pre-registered filters from the ClassMethodsHydrator hydrator are ignored when this interface is used. More on those methods below. Filter-enabled hydrators and the composite filter Hydrators can indicate they are filter-enabled by implementing Zend\\Hydrator\\Filter\\FilterEnabledInterface : namespace Zend\\Hydrator\\Filter; interface FilterEnabledInterface extends FilterProviderInterface { /** * Add a new filter to take care of what needs to be hydrated. * To exclude e.g. the method getServiceLocator: * * <code> * $composite->addFilter( * \"servicelocator\", * function ($property) { * [$class, $method] = explode('::', $property, 2); * return $method !== 'getServiceLocator'; * }, * FilterComposite::CONDITION_AND * ); * </code> * * @param string $name Index in the composite * @param callable|FilterInterface $filter */ public function addFilter(string $name, $filter, int $condition = FilterComposite::CONDITION_OR) : void; /** * Check whether a specific filter exists at key $name or not * * @param string $name Index in the composite */ public function hasFilter(string $name) : bool; /** * Remove a filter from the composition. * * To not extract \"has\" methods, you simply need to unregister it * * <code> * $filterComposite->removeFilter('has'); * </code> */ public function removeFilter(string $name) : void; } Note that the interface extends FilterProviderInterface , which means it also includes the getFilter() method. The FilterEnabledInterface makes the assumption that the class will be backed by a Zend\\Hydrator\\Filter\\FilterComposite ; the various addFilter() , hasFilter() , and removeFilter() methods are expected to proxy to a FilterComposite instance. AbstractHydrator , on which all the hydrators shipped in this package are built, implements FilterEnabledInterface . Of the hydrators shipped, only one, ClassMethodsHydrator , defines any filters from the outset. Its constructor includes the following: $this->filterComposite->addFilter('is', new IsFilter()); $this->filterComposite->addFilter('has', new HasFilter()); $this->filterComposite->addFilter('get', new GetFilter()); $this->filterComposite->addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND ); Remove filters If you want to tell a filter-enabled hydrator such as ClassMethodsHydrator not to extract methods that start with is , remove the related filter: $hydrator = new ClassMethodsHydrator(false); $hydrator->removeFilter('is'); After performing the above, the key/value pairs for is methods will no longer end up in your extracted array. Add filters You can add filters using the addFilter() method. Filters can either implement FilterInterface , or simply be PHP callables: $hydrator->addFilter('len', function($property) { return strlen($property) === 3; }); By default, every filter you add will be added with a conditional OR . If you want to add it with AND (such as the ClassMethodsHydrator does with its composed NumberOfParameterFilter , demonstrated above) provide the conditon as the third argument to addFilter : $hydrator->addFilter('len', function($property) { return strlen($property) === 3; }, FilterComposite::CONDITION_AND); One common use case for filters is to omit getters for values that you do not want to represent, such as a service manager instance: $hydrator->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); The example above will exclude the getServiceManager() method and the servicemanager key from extraction, even if the get filter wants to add it.","title":"Filters"},{"location":"v3/filter/#zend92hydrator92filter","text":"Hydrator filters allow you to manipulate the behavior of the extract() operation. This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation. It comes with a helpful Composite implementation, and several filters for common use cases. The filters are composed in the AbstractHydrator , so you can start using them immediately in any custom extensions you write that extend that class. namespace Zend\\Hydrator\\Filter; interface FilterInterface { /** * Should return true, if the given filter does not match. */ public function filter(string $property) : bool; } ``` If it returns true, the key/value pairs will be in the extracted arrays - if it returns false, you'll not see them again. ## Filter implementations ### Zend\\\\Hydrator\\\\Filter\\\\GetFilter This filter is used in the `ClassMethodsHydrator` to decide which getters will be extracted. It checks if the key to extract starts with `get` or the object contains a method beginning with `get` (e.g., `Zend\\Foo\\Bar::getFoo`). ### Zend\\\\Hydrator\\\\Filter\\\\HasFilter This filter is used in the `ClassMethodsHydrator` to decide which `has` methods will be extracted. It checks if the key to extract begins with `has` or the object contains a method beginning with `has` (e.g., `Zend\\Foo\\Bar::hasFoo`). ### Zend\\\\Hydrator\\\\Filter\\\\IsFilter This filter is used in the `ClassMethodsHydrator` to decide which `is` methods will be extracted. It checks if the key to extract begins with `is` or the object contains a method beginning with `is` (e.g., `Zend\\Foo\\Bar::isFoo`). ### Zend\\\\Hydrator\\\\Filter\\\\MethodMatchFilter This filter allows you to omit methods during extraction that match the condition defined in the composite. The name of the method is specified in the constructor of this filter; the second parameter decides whether to use white or blacklisting to decide (whitelisting retains only the matching method, blacklist omits any matching method). The default is blacklisting - pass `false` to change the behavior. ### Zend\\\\Hydrator\\\\Filter\\\\NumberOfParameterFilter This filter is used in the `ClassMethodsHydrator` to check the number of parameters. By convention, the `get`, `has` and `is` methods do not get any parameters - but it may happen. You can add your own number of required parameters, simply add the number to the constructor. The default value is 0. If the method has more or fewer parameters than what the filter accepts, it will be omitted. ## Use FilterComposite for complex filters `FilterComposite` implements `FilterInterface` as well, so you can add it as a regular filter to the hydrator. One benefit of this implementation is that you can add the filters with a condition and accomplish complex requirements using different filters with different conditions. You can pass the following conditions to the 3rd parameter, when you add a filter: ### Zend\\\\Hydrator\\\\Filter\\\\FilterComposite::CONDITION\\_OR At the given level of the composite, at least one filter set using `CONDITION_OR` must return true to extract the value. ### Zend\\\\Hydrator\\\\Filter\\\\FilterComposite::CONDITION\\_AND At the given level of the composite, **all** filters set using `CONDITION_AND` must return true to extract the value. ### FilterComposite Examples To illustrate how conditions apply when composing filters, consider the following set of filters: ```php $composite = new FilterComposite(); $composite->addFilter('one', $condition1); $composite->addFilter('two', $condition2); $composite->addFilter('three', $condition3); $composite->addFilter('four', $condition4, FilterComposite::CONDITION_AND); $composite->addFilter('five', $condition5, FilterComposite::CONDITION_AND); ``` The above is roughly equivalent to the following conditional: // This is what's happening internally if ( ($condition1 || $condition2 || $condition3 ) && ($condition4 && $condition5 ) ) { // do extraction } If you only have one condition block (e.g., only `AND` or `OR` filters), the other condition type will be completely ignored. A bit more complex filter can look like this: ```php $composite = new FilterComposite(); $composite->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $composite->addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $hydrator->addFilter('excludes', $composite, FilterComposite::CONDITION_AND); // Internal if (( // default composite inside the ClassMethodsHydrator: ($getFilter || $hasFilter || $isFilter ) && ( $numberOfParameterFilter ) ) && ( // new composite, added to the one above $serviceManagerFilter && $eventManagerFilter ) ) { // do extraction } If you perform this on the ClassMethodsHydrator , all getters will get extracted, except for getServiceManager() and getEventManager() .","title":"Zend\\Hydrator\\Filter"},{"location":"v3/filter/#using-the-provider-interface","text":"Zend\\Hydrator\\Filter\\FilterProviderInterface allows you to configure the behavior of the hydrator inside your objects. namespace Zend\\Hydrator\\Filter; interface FilterProviderInterface { /** * Provides a filter for hydration * * @return FilterInterface */ public function getFilter(); } (The getFilter() method is automatically excluded from extract() .) If the extracted object implements the Zend\\Hydrator\\Filter\\FilterProviderInterface , the returned FilterInterface instance can also be a FilterComposite . For example: Class Foo implements FilterProviderInterface { public function getFoo() { return 'foo'; } public function hasFoo() { return true; } public function getServiceManager() { return 'servicemanager'; } public function getEventManager() { return 'eventmanager'; } public function getFilter() { $composite = new FilterComposite(); $composite->addFilter('get', new GetFilter()); $exclusionComposite = new FilterComposite(); $exclusionComposite->addFilter( 'servicemanager', new MethodMatchFilter('getServiceManager'), FilterComposite::CONDITION_AND ); $exclusionComposite->addFilter( 'eventmanager', new MethodMatchFilter('getEventManager'), FilterComposite::CONDITION_AND ); $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND); return $composite; } } $hydrator = new ClassMethodsHydrator(false); $extractedArray = $hydrator->extract(new Foo()); $extractedArray will only have 'foo' => 'foo'; all other values are excluded from extraction.","title":"Using the provider interface"},{"location":"v3/filter/#filter-enabled-hydrators-and-the-composite-filter","text":"Hydrators can indicate they are filter-enabled by implementing Zend\\Hydrator\\Filter\\FilterEnabledInterface : namespace Zend\\Hydrator\\Filter; interface FilterEnabledInterface extends FilterProviderInterface { /** * Add a new filter to take care of what needs to be hydrated. * To exclude e.g. the method getServiceLocator: * * <code> * $composite->addFilter( * \"servicelocator\", * function ($property) { * [$class, $method] = explode('::', $property, 2); * return $method !== 'getServiceLocator'; * }, * FilterComposite::CONDITION_AND * ); * </code> * * @param string $name Index in the composite * @param callable|FilterInterface $filter */ public function addFilter(string $name, $filter, int $condition = FilterComposite::CONDITION_OR) : void; /** * Check whether a specific filter exists at key $name or not * * @param string $name Index in the composite */ public function hasFilter(string $name) : bool; /** * Remove a filter from the composition. * * To not extract \"has\" methods, you simply need to unregister it * * <code> * $filterComposite->removeFilter('has'); * </code> */ public function removeFilter(string $name) : void; } Note that the interface extends FilterProviderInterface , which means it also includes the getFilter() method. The FilterEnabledInterface makes the assumption that the class will be backed by a Zend\\Hydrator\\Filter\\FilterComposite ; the various addFilter() , hasFilter() , and removeFilter() methods are expected to proxy to a FilterComposite instance. AbstractHydrator , on which all the hydrators shipped in this package are built, implements FilterEnabledInterface . Of the hydrators shipped, only one, ClassMethodsHydrator , defines any filters from the outset. Its constructor includes the following: $this->filterComposite->addFilter('is', new IsFilter()); $this->filterComposite->addFilter('has', new HasFilter()); $this->filterComposite->addFilter('get', new GetFilter()); $this->filterComposite->addFilter( 'parameter', new NumberOfParameterFilter(), FilterComposite::CONDITION_AND );","title":"Filter-enabled hydrators and the composite filter"},{"location":"v3/migration/","text":"Migration from version 2 This document details changes made between version 2 and version 3 that could affect end-users. Minimum supported versions PHP Version 3 bumps the minimum supported PHP version to version 7.2. We chose this version in particular as it provides the object typehint, which allows us to enforce at the engine level what we were previously enforcing only at the documentation level. Additionally, we have enabled strict types in all class files shipped with this component. zend-eventmanager The minimum supported version of zend-eventmanager (used by the AggregateHydrator )is now 3.2.1. zend-serializer The minimum supported version of zend-serializer (used by the SerializableStrategy ) is now 2.9.0. zend-servicemanager The minimum supported version of zend-servicemanager (used by the HydratorPluginManager ) is now 3.3.2. Renamed interfaces The following interfaces were renamed: Zend\\Hydrator\\FilterEnabledInterface becomes Zend\\Hydrator\\Filter\\FilterEnabledInterface . Zend\\Hydrator\\NamingStrategyEnabledInterface becomes Zend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface . Zend\\Hydrator\\StrategyEnabledInterface becomes Zend\\Hydrator\\Strategy\\StrategyEnabledInterface . Renamed classes The following classes were renamed: Zend\\Hydrator\\ArraySerializable becomes Zend\\Hydrator\\ArraySerializableHydrator Zend\\Hydrator\\ClassMethods becomes Zend\\Hydrator\\ClassMethodsHydrator Zend\\Hydrator\\ObjectProperty becomes Zend\\Hydrator\\ObjectPropertyHydrator Zend\\Hydrator\\Reflection becomes Zend\\Hydrator\\ReflectionHydrator In each case, a class named after the original has been created as a deprecated extension of the new class. This means you can continue to use the old class names, but only until version 4, at which point they will be removed. Additionally, aliases for the old class names have been added to the HydratorPluginManager , pointing to services named after the new class names. Interface changes Each of the interfaces provided by this package have been updated to add typehints where they were previously omitted (due to engine limitations), both on parameters and return values. These include: Zend\\Hydrator\\ExtractionInterface : extract($object) becomes extract(object $object) : array Zend\\Hydrator\\Filter\\FilterEnabledInterface (was Zend\\Hydrator\\FilterEnabledInterface ): addFilter($name, $filter, $condition = Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) becomes addFilter(string $name, $filter, int $condition = Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) : void hasFilter($name) becomes hasFilter(string $name) : bool removeFilter($name) becomes removeFilter(string $name) : void Zend\\Hydrator\\HydrationInterface : hydrate(array $data, $object) becomes hydrate(array $data, object $object) Zend\\Hydrator\\HydratorAwareInterface : setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) becomes setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) : void getHydrator() becomes getHydrator() : ?Zend\\Hydrator\\HydratorInterface Zend\\Hydrator\\HydratorAwareTrait was updated to follow the interface; if you use the trait to implement the interface, no changes will be necessary. Zend\\Hydrator\\HydratorOptionsInterface : setOptions($options) becomes setOptions(iterable $options) : void Zend\\Hydrator\\HydratorProviderInterface : getHydratorConfig() becomes getHydratorConfig() : array Zend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface (was Zend\\Hydrator\\NamingStrategyEnabledInterface ): setNamingStrategy(Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) becomes setNamingStrategy(Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) : void getNamingStrategy() becomes getNamingStrategy() : Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface removeNamingStrategy() becomes removeNamingStrategy() : void Zend\\Hydrator\\Strategy\\StrategyEnabledInterface (was Zend\\Hydrator\\StrategyEnabledInterface ): addStrategy($name, Zend\\Hydrator\\Strategy\\StrategyInterface $strategy) becomes addStrategy(string $name, Zend\\Hydrator\\Strategy\\StrategyInterface $strategy) : void getStrategy($name) becomes getStrategy(string $name) : Zend\\Hydrator\\Strategy\\StrategyInterface hasStrategy($name) becomes hasStrategy(string $name) : bool removeStrategy($name) becomes removeStrategy(string $name) : void Zend\\Hydrator\\Filter\\FilterInterface : filter($property) becomes filter(string $property) : bool Zend\\Hydrator\\Filter\\FilterProviderInterface : getFilter() becomes getFilter() : Zend\\Hydrator\\Filter\\FilterInterface Zend\\Hydrator\\Iterator\\HydratingIteratorInterface : setPrototype($prototype) becomes setPrototype($prototype) : void ( $prototype continues to allow either a string or object) setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) becomes setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) : void Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface : extract($name) becomes extract(string $name, ?object $object = null) : string hydrate($name) becomes hydrate(string $name, ?array $data = null) : string Zend\\Hydrator\\Strategy\\StrategyInterface : hydrate($value) becomes hydrate($value, ?array $data = null) (the $value parameter and return value can be any PHP type) extract($value) becomes extract($value, ?object $object = null) (the $value parameter and return value can be any PHP type) All implementations of these interface shipped in the component have been updated to ensure signatures match. If you are providing custom implementations, or extending the implementations provided in this package, you may need to update signatures per the above. Typehints As noted in the above section, typehints were added to all interfaces. In addition to those changes, the following methods were also updated to add typehints: Zend\\Hydrator\\Aggregate\\AggregateHydrator : add(Zend\\Hydrator\\HydratorInterface $hydrator, $priority = self::DEFAULT_PRIORITY) becomes add(Zend\\Hydrator\\HydratorInterface $hydrator, int $priority = self::DEFAULT_PRIORITY) : void Zend\\Hydrator\\Aggregate\\ExtractEvent : __construct($target, $extractionObject) becomes __construct(object $target, object $extractionObject) getExtractionObject() becomes getExtractionObject() : object setExtractionObject($extractionObject) becomes setExtractionObject(object $extractionObject) : void getExtractedData() becomes getExtractedData() : array setExtractedData(array $extractedData) becomes setExtractedData(array $extractedData) : void mergeExtractedData(array $additionalData) becomes mergeExtractedData(array $additionalData) : void Zend\\Hydrator\\Aggregate\\HydrateEvent : __construct($target, $hydratedObject, array $hydrationData) becomes __construct(object $target, object $hydratedObject, array $hydrationData) getHydratedObject() becomes getHydratedObject() : object setHydratedObject($hydratedObject) becomes setHydratedObject(object $hydratedObject) : void getHydrationData() becomes getHydrationData() : array setHydrationData(array $hydrationData) becomes setHydrationData(array $hydrationData) : void Zend\\Hydrator\\Aggregate\\HydratorListener : onHydrate(HydrateEvent $event) becomes onHydrate(HydrateEvent $event) : object onExtract(ExtractEvent $event) becomes onExtract(ExtractEvent $event) : array Zend\\Hydrator\\ClassMethodsHydrator (was Zend\\Hydrator\\ClassMethods ): __construct($underscoreSeparatedKeys = true, $methodExistsCheck = false) becomes __construct(bool $underscoreSeparatedKeys = true, bool $methodExistsCheck = false) setUnderscoreSeparatedKeys($underscoreSeparatedKeys) becomes setUnderscoreSeparatedKeys(bool $underscoreSeparatedKeys) : void getUnderscoreSeparatedKeys() becomes getUnderscoreSeparatedKeys() : bool setMethodExistsCheck($methodExistsCheck) becomes setMethodExistsCheck(bool $methodExistsCheck) : void getMethodExistsCheck() becomes getMethodExistsCheck() : bool Zend\\Hydrator\\ConfigProvider : __invoke() becomes __invoke() : array getDependencyConfig() becomes getDependencyConfig() : array Zend\\Hydrator\\DelegatingHydratorFactory : no longer implements Zend\\ServiceManager\\FactoryInterface __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null) becomes __invoke(Psr\\Container\\ContainerInterface $container) : Zend\\Hydrator\\DelegatingHydrator Zend\\Hydrator\\Filter\\FilterComposite : __construct($orFilters = [], $andFilters = []) becomes __construct(array $orFilters = [], array $andFilters = []) Zend\\Hydrator\\Filter\\MethodMatchFilter : __construct($method, $exclude = true) becomes __construct(string $method, bool $exclude = true) Zend\\Hydrator\\Filter\\NumberOfParameterFilter : __construct($numberOfParameters = 0) becomes __construct(int $numberOfParameters = 0) Zend\\Hydrator\\HydratorPluginManagerFactory : no longer implements Zend\\ServiceManager\\FactoryInterface __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null) becomes __invoke(Psr\\Container\\ContainerInterface $container, string $name, ?array $options = []) : Zend\\Hydrator\\HydratorPluginManager Zend\\Hydrator\\Module : getConfig() becomes getConfig() : array init($moduleManager) becomes init(Zend\\ModuleManager\\ModuleManager $moduleManager) : void Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy : __construct(array $strategies, Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null) becomes __construct(array $strategies, ?Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null) Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\CamelCaseToUnderscoreFilter : filter($value) becomes filter(string $value) : string Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\UnderscoreToCamelCaseFilter : filter($value) becomes filter(string $value) : string Zend\\Hydrator\\Strategy\\ClosureStrategy : __construct($extractFunc = null, $hydrateFunc = null) becomes __construct(?callable $extractFunc = null, ?callable $hydrateFunc = null) Zend\\Hydrator\\Strategy\\CollectionStrategy : __construct(Zend\\Hydrator\\HydratorInterface $objectHydrator, $objectClassName) becomes __construct(Zend\\Hydrator\\HydratorInterface $objectHydrator, string $objectClassName) Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy : __construct($format = DateTime::RFC3339, DateTimeZone $timezone = null, $dateTimeFallback = false) becomes __construct(string $format = DateTime::RFC3339, ?DateTimeZone $timezone = null, bool $dateTimeFallback = false) Zend\\Hydrator\\Strategy\\ExplodeStrategy : __construct($delimiter = ',', $explodeLimit = null) becomes __construct(string $delimiter = ',', ?int $explodeLimit = null) Zend\\Hydrator\\Strategy\\SerializableStrategy : __construct($serializer, $serializerOptions = null) becomes __construct($serializer, ?iterable $serializerOptions = null) setSerializer($serializer) becomes setSerializer($serializer) : void getSerializer() becomes getSerializer($serializer) : Zend\\Serializer\\Adapter\\AdapterInterface setSerializerOptions($serializerOptions) becomes setSerializerOptions(iterable $serializerOptions) : void getSerializerOptions() becomes getSerializerOptions() : array Zend\\Hydrator\\Strategy\\StrategyChain : __construct($extractionStrategies) becomes __construct(iterable $extractionStrategies) ArrayMapNamingStrategy and MapNamingStrategy merged ArrayMapNamingStrategy and MapNamingStrategy were performing essentially the same duties, but in reverse. As such, for version 3, we have merged the two into MapNamingStrategy . To accommodate the three different use cases, we provide three \"named constructors\": public static function createFromExtractionMap(array $extractionMap) : MapNamingStrategy; public static function createFromHydrationMap(array $hydrationMap) : MapNamingStrategy; public static function createFromAsymmetricMap(array $extractionMap, array $hydrationMap) : MapNamingStrategy; In the first two cases, the constructor will flip the arrays for purposes of the opposite interaction; e.g., using createFromExtractionMap() will create a hydration map based on an array_flip() of the extraction map provided. You MUST use one of these methods to create an instance, as the constructor is now marked private . HydratorPluginManager This version removes support for zend-servicemanager v2 service names. Under zend-servicemanager v2, most special characters were removed, and the name normalized to all lowercase. Now, only fully qualified class names are mapped to factories, and short names (names omitting the namespace and/or \"Hydrator\" suffix) are mapped as aliases. Additionally, version 3 ships a standalone, PSR-11 compliant version, Zend\\Hydrator\\StandaloneHydratorPluginManager . By default, the HydratorManager service alias will point to the StandaloneHydratorPluginManager if zend-servicemanager is not installed, and the HydratorPluginManager otherwise. See the plugin managers chapter for more details.","title":"Migration"},{"location":"v3/migration/#migration-from-version-2","text":"This document details changes made between version 2 and version 3 that could affect end-users.","title":"Migration from version 2"},{"location":"v3/migration/#minimum-supported-versions","text":"","title":"Minimum supported versions"},{"location":"v3/migration/#renamed-interfaces","text":"The following interfaces were renamed: Zend\\Hydrator\\FilterEnabledInterface becomes Zend\\Hydrator\\Filter\\FilterEnabledInterface . Zend\\Hydrator\\NamingStrategyEnabledInterface becomes Zend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface . Zend\\Hydrator\\StrategyEnabledInterface becomes Zend\\Hydrator\\Strategy\\StrategyEnabledInterface .","title":"Renamed interfaces"},{"location":"v3/migration/#renamed-classes","text":"The following classes were renamed: Zend\\Hydrator\\ArraySerializable becomes Zend\\Hydrator\\ArraySerializableHydrator Zend\\Hydrator\\ClassMethods becomes Zend\\Hydrator\\ClassMethodsHydrator Zend\\Hydrator\\ObjectProperty becomes Zend\\Hydrator\\ObjectPropertyHydrator Zend\\Hydrator\\Reflection becomes Zend\\Hydrator\\ReflectionHydrator In each case, a class named after the original has been created as a deprecated extension of the new class. This means you can continue to use the old class names, but only until version 4, at which point they will be removed. Additionally, aliases for the old class names have been added to the HydratorPluginManager , pointing to services named after the new class names.","title":"Renamed classes"},{"location":"v3/migration/#interface-changes","text":"Each of the interfaces provided by this package have been updated to add typehints where they were previously omitted (due to engine limitations), both on parameters and return values. These include: Zend\\Hydrator\\ExtractionInterface : extract($object) becomes extract(object $object) : array Zend\\Hydrator\\Filter\\FilterEnabledInterface (was Zend\\Hydrator\\FilterEnabledInterface ): addFilter($name, $filter, $condition = Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) becomes addFilter(string $name, $filter, int $condition = Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR) : void hasFilter($name) becomes hasFilter(string $name) : bool removeFilter($name) becomes removeFilter(string $name) : void Zend\\Hydrator\\HydrationInterface : hydrate(array $data, $object) becomes hydrate(array $data, object $object) Zend\\Hydrator\\HydratorAwareInterface : setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) becomes setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) : void getHydrator() becomes getHydrator() : ?Zend\\Hydrator\\HydratorInterface Zend\\Hydrator\\HydratorAwareTrait was updated to follow the interface; if you use the trait to implement the interface, no changes will be necessary. Zend\\Hydrator\\HydratorOptionsInterface : setOptions($options) becomes setOptions(iterable $options) : void Zend\\Hydrator\\HydratorProviderInterface : getHydratorConfig() becomes getHydratorConfig() : array Zend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface (was Zend\\Hydrator\\NamingStrategyEnabledInterface ): setNamingStrategy(Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) becomes setNamingStrategy(Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $strategy) : void getNamingStrategy() becomes getNamingStrategy() : Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface removeNamingStrategy() becomes removeNamingStrategy() : void Zend\\Hydrator\\Strategy\\StrategyEnabledInterface (was Zend\\Hydrator\\StrategyEnabledInterface ): addStrategy($name, Zend\\Hydrator\\Strategy\\StrategyInterface $strategy) becomes addStrategy(string $name, Zend\\Hydrator\\Strategy\\StrategyInterface $strategy) : void getStrategy($name) becomes getStrategy(string $name) : Zend\\Hydrator\\Strategy\\StrategyInterface hasStrategy($name) becomes hasStrategy(string $name) : bool removeStrategy($name) becomes removeStrategy(string $name) : void Zend\\Hydrator\\Filter\\FilterInterface : filter($property) becomes filter(string $property) : bool Zend\\Hydrator\\Filter\\FilterProviderInterface : getFilter() becomes getFilter() : Zend\\Hydrator\\Filter\\FilterInterface Zend\\Hydrator\\Iterator\\HydratingIteratorInterface : setPrototype($prototype) becomes setPrototype($prototype) : void ( $prototype continues to allow either a string or object) setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) becomes setHydrator(Zend\\Hydrator\\HydratorInterface $hydrator) : void Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface : extract($name) becomes extract(string $name, ?object $object = null) : string hydrate($name) becomes hydrate(string $name, ?array $data = null) : string Zend\\Hydrator\\Strategy\\StrategyInterface : hydrate($value) becomes hydrate($value, ?array $data = null) (the $value parameter and return value can be any PHP type) extract($value) becomes extract($value, ?object $object = null) (the $value parameter and return value can be any PHP type) All implementations of these interface shipped in the component have been updated to ensure signatures match. If you are providing custom implementations, or extending the implementations provided in this package, you may need to update signatures per the above.","title":"Interface changes"},{"location":"v3/migration/#typehints","text":"As noted in the above section, typehints were added to all interfaces. In addition to those changes, the following methods were also updated to add typehints: Zend\\Hydrator\\Aggregate\\AggregateHydrator : add(Zend\\Hydrator\\HydratorInterface $hydrator, $priority = self::DEFAULT_PRIORITY) becomes add(Zend\\Hydrator\\HydratorInterface $hydrator, int $priority = self::DEFAULT_PRIORITY) : void Zend\\Hydrator\\Aggregate\\ExtractEvent : __construct($target, $extractionObject) becomes __construct(object $target, object $extractionObject) getExtractionObject() becomes getExtractionObject() : object setExtractionObject($extractionObject) becomes setExtractionObject(object $extractionObject) : void getExtractedData() becomes getExtractedData() : array setExtractedData(array $extractedData) becomes setExtractedData(array $extractedData) : void mergeExtractedData(array $additionalData) becomes mergeExtractedData(array $additionalData) : void Zend\\Hydrator\\Aggregate\\HydrateEvent : __construct($target, $hydratedObject, array $hydrationData) becomes __construct(object $target, object $hydratedObject, array $hydrationData) getHydratedObject() becomes getHydratedObject() : object setHydratedObject($hydratedObject) becomes setHydratedObject(object $hydratedObject) : void getHydrationData() becomes getHydrationData() : array setHydrationData(array $hydrationData) becomes setHydrationData(array $hydrationData) : void Zend\\Hydrator\\Aggregate\\HydratorListener : onHydrate(HydrateEvent $event) becomes onHydrate(HydrateEvent $event) : object onExtract(ExtractEvent $event) becomes onExtract(ExtractEvent $event) : array Zend\\Hydrator\\ClassMethodsHydrator (was Zend\\Hydrator\\ClassMethods ): __construct($underscoreSeparatedKeys = true, $methodExistsCheck = false) becomes __construct(bool $underscoreSeparatedKeys = true, bool $methodExistsCheck = false) setUnderscoreSeparatedKeys($underscoreSeparatedKeys) becomes setUnderscoreSeparatedKeys(bool $underscoreSeparatedKeys) : void getUnderscoreSeparatedKeys() becomes getUnderscoreSeparatedKeys() : bool setMethodExistsCheck($methodExistsCheck) becomes setMethodExistsCheck(bool $methodExistsCheck) : void getMethodExistsCheck() becomes getMethodExistsCheck() : bool Zend\\Hydrator\\ConfigProvider : __invoke() becomes __invoke() : array getDependencyConfig() becomes getDependencyConfig() : array Zend\\Hydrator\\DelegatingHydratorFactory : no longer implements Zend\\ServiceManager\\FactoryInterface __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null) becomes __invoke(Psr\\Container\\ContainerInterface $container) : Zend\\Hydrator\\DelegatingHydrator Zend\\Hydrator\\Filter\\FilterComposite : __construct($orFilters = [], $andFilters = []) becomes __construct(array $orFilters = [], array $andFilters = []) Zend\\Hydrator\\Filter\\MethodMatchFilter : __construct($method, $exclude = true) becomes __construct(string $method, bool $exclude = true) Zend\\Hydrator\\Filter\\NumberOfParameterFilter : __construct($numberOfParameters = 0) becomes __construct(int $numberOfParameters = 0) Zend\\Hydrator\\HydratorPluginManagerFactory : no longer implements Zend\\ServiceManager\\FactoryInterface __invoke(Interop\\Container\\ContainerInterface $container, $requestedName, array $options = null) becomes __invoke(Psr\\Container\\ContainerInterface $container, string $name, ?array $options = []) : Zend\\Hydrator\\HydratorPluginManager Zend\\Hydrator\\Module : getConfig() becomes getConfig() : array init($moduleManager) becomes init(Zend\\ModuleManager\\ModuleManager $moduleManager) : void Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy : __construct(array $strategies, Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null) becomes __construct(array $strategies, ?Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface $defaultNamingStrategy = null) Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\CamelCaseToUnderscoreFilter : filter($value) becomes filter(string $value) : string Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\\UnderscoreToCamelCaseFilter : filter($value) becomes filter(string $value) : string Zend\\Hydrator\\Strategy\\ClosureStrategy : __construct($extractFunc = null, $hydrateFunc = null) becomes __construct(?callable $extractFunc = null, ?callable $hydrateFunc = null) Zend\\Hydrator\\Strategy\\CollectionStrategy : __construct(Zend\\Hydrator\\HydratorInterface $objectHydrator, $objectClassName) becomes __construct(Zend\\Hydrator\\HydratorInterface $objectHydrator, string $objectClassName) Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy : __construct($format = DateTime::RFC3339, DateTimeZone $timezone = null, $dateTimeFallback = false) becomes __construct(string $format = DateTime::RFC3339, ?DateTimeZone $timezone = null, bool $dateTimeFallback = false) Zend\\Hydrator\\Strategy\\ExplodeStrategy : __construct($delimiter = ',', $explodeLimit = null) becomes __construct(string $delimiter = ',', ?int $explodeLimit = null) Zend\\Hydrator\\Strategy\\SerializableStrategy : __construct($serializer, $serializerOptions = null) becomes __construct($serializer, ?iterable $serializerOptions = null) setSerializer($serializer) becomes setSerializer($serializer) : void getSerializer() becomes getSerializer($serializer) : Zend\\Serializer\\Adapter\\AdapterInterface setSerializerOptions($serializerOptions) becomes setSerializerOptions(iterable $serializerOptions) : void getSerializerOptions() becomes getSerializerOptions() : array Zend\\Hydrator\\Strategy\\StrategyChain : __construct($extractionStrategies) becomes __construct(iterable $extractionStrategies)","title":"Typehints"},{"location":"v3/migration/#arraymapnamingstrategy-and-mapnamingstrategy-merged","text":"ArrayMapNamingStrategy and MapNamingStrategy were performing essentially the same duties, but in reverse. As such, for version 3, we have merged the two into MapNamingStrategy . To accommodate the three different use cases, we provide three \"named constructors\": public static function createFromExtractionMap(array $extractionMap) : MapNamingStrategy; public static function createFromHydrationMap(array $hydrationMap) : MapNamingStrategy; public static function createFromAsymmetricMap(array $extractionMap, array $hydrationMap) : MapNamingStrategy; In the first two cases, the constructor will flip the arrays for purposes of the opposite interaction; e.g., using createFromExtractionMap() will create a hydration map based on an array_flip() of the extraction map provided. You MUST use one of these methods to create an instance, as the constructor is now marked private .","title":"ArrayMapNamingStrategy and MapNamingStrategy merged"},{"location":"v3/migration/#hydratorpluginmanager","text":"This version removes support for zend-servicemanager v2 service names. Under zend-servicemanager v2, most special characters were removed, and the name normalized to all lowercase. Now, only fully qualified class names are mapped to factories, and short names (names omitting the namespace and/or \"Hydrator\" suffix) are mapped as aliases. Additionally, version 3 ships a standalone, PSR-11 compliant version, Zend\\Hydrator\\StandaloneHydratorPluginManager . By default, the HydratorManager service alias will point to the StandaloneHydratorPluginManager if zend-servicemanager is not installed, and the HydratorPluginManager otherwise. See the plugin managers chapter for more details.","title":"HydratorPluginManager"},{"location":"v3/plugin-managers/","text":"Plugin Managers It can be useful to compose a plugin manager from which you can retrieve hydrators; in fact, Zend\\Hydrator\\DelegatingHydrator does exactly that! With such a manager, you can retrieve instances using short names, or instances that have dependencies on other services, without needing to know the details of how that works. Examples of Hydrator plugin managers in real-world scenarios include: hydrating database result sets preparing API payloads HydratorPluginManagerInterface We provide two plugin manager implementations. Essentially, they only need to implement the PSR-11 ContainerInterface , but plugin managers in current versions of zend-servicemanager only implement it indirectly via the container-interop project. As such, we ship Zend\\Hydrator\\HydratorPluginManagerInterface , which simply extends the PSR-11 Psr\\Container\\ContainerInterface . Each of our implementations implement it. HydratorPluginManager If you have used zend-hydrator prior to version 3, you are likely already familiar with this class, as it has been the implementation we have shipped from initial versions. The HydratorPluginManager extends the zend-servicemanager AbstractPluginManager , and has the following behaviors: It will only return Zend\\Hydrator\\HydratorInterface instances. It defines short-name aliases for all shipped hydrators (the class name minus the namespace), in a variety of casing combinations. All but the DelegatingHydrator are defined as invokable services (meaning they can be instantiated without any constructor arguments). The DelegatingHydrator is configured as a factory-based service, mapping to the Zend\\Hydrator\\DelegatingHydratorFactory . No services are shared; a new instance is created each time you call get() . HydratorPluginManagerFactory Zend\\Hydrator\\HydratorPluginManager is mapped to the factory Zend\\Hydrator\\HydratorPluginManagerFactory when wired to the dependency injection container. The factory will look for the config service, and use the hydrators configuration key to seed it with additional services. This configuration key should map to an array that follows standard zend-servicemanager configuration . StandaloneHydratorPluginManager Zend\\Hydrator\\StandaloneHydratorPluginManager provides an implementation that has no dependencies on other libraries. It can only load the hydrators shipped with zend-hydrator . StandardHydratorPluginManagerFactory Zend\\Hydrator\\StandardHydratorPluginManager is mapped to the factory Zend\\Hydrator\\StandardHydratorPluginManagerFactory when wired to the dependency injection container. HydratorManager alias Zend\\Hydrator\\ConfigManager defines an alias service, HydratorManager . That service will point to Zend\\Hydrator\\HydratorPluginManager if zend-servicemanager is installed, and Zend\\Hydrator\\StandaloneHydratorPluginManager otherwise. Custom plugin managers If you do not want to use zend-servicemanager, but want a plugin manager that is customizable, or at least capable of loading the hydrators you have defined for your application, you should write a custom implementation of Zend\\Hydrator\\HydratorPluginManagerInterface , and wire it to the HydratorManager service, and/or one of the existing service names. As an example, if you want a configurable solution that uses factories, and want those factories capable of pulling application-level dependencies, you might do something like the following: // In src/YourApplication/CustomHydratorPluginManager.php: namespace YourApplication; use Psr\\Container\\NotFoundExceptionInterface; use Psr\\Container\\ContainerInterface; use RuntimeException; use Zend\\Hydrator\\HydratorInterface; use Zend\\Hydrator\\HydratorPluginManagerInterface; use Zend\\Hydrator\\StandaloneHydratorPluginManager; class CustomHydratorPluginManager implements HydratorPluginManagerInterface { /** @var ContainerInterface */ private $appContainer; /** @var StandaloneHydratorPluginManager */ private $defaults; /** @var array<string, string|callable> */ private $factories = []; public function __construct(ContainerInterface $appContainer) { $this->appContainer = $appContainer; $this->defaults = new StandaloneHydratorPluginManager(); } /** * {@inheritDoc} */ public function get($id) : HydratorInterface { if (! isset($this->factories[$id]) && ! $this->defaults->has($id)) { $message = sprintf('Hydrator service %s not found', $id); throw new class($message) extends RuntimeException implements NotFoundExceptionInterface {}; } // Default was requested; fallback to standalone container if (! isset($this->factories[$id])) { return $this->defaults->get($id); } $factory = $this->factories[$id]; if (is_string($factory)) { $this->factories[$id] = $factory = new $factory(); } return $factory($this->appContainer, $id); } public function has($id) : bool { return isset($this->factories[$id]) || $this->defaults->has($id); } public function setFactoryClass(string $name, string $factory) : void { $this->factories[$name] = $factory; } public function setFactory(string $name, callable $factory) : void { $this->factories[$name] = $factory; } } // In src/YourApplication/CustomHydratorPluginManagerFactory.php: namespace YourApplication; use Psr\\Container\\ContainerInterface; class CustomHydratorPluginManagerFactory { public function __invoke(ContainerInterface $container) : CustomHydratorPluginManager { $config = $container->has('config') ? $container->get('config') : []; $config = $config['hydrators']['factories'] ?? []; $manager = new CustomHydratorPluginManager($this); if ([] !== $config) { $this->configureManager($manager, $config); } return $manager; } /** * @param array<string, string|callable> $config */ private function configureManager(CustomHydratorPluginManager $manager, array $config) : void { foreach ($config as $name => $factory) { is_string($factory) ? $manager->setFactoryClass($name, $factory) : $manager->setFactory($name, $factory); } } } // in config/autoload/hydrators.global.php or similar: return [ 'dependencies' => [ 'aliases' => [ 'HydratorManager' => \\YourApplication\\CustomHydratorPluginManager::class, ], 'factories' => [ \\YourApplication\\CustomHydratorPluginManager::class => \\YourApplication\\CustomHydratorPluginManagerFactory::class ], ], 'hydrators' => [ 'factories' => [ \\Blog\\PostHydrator::class => \\Blog\\PostHydratorFactory::class, \\News\\ItemHydrator::class => \\News\\ItemHydratorFactory::class, // etc. ], ], ];","title":"Plugin Managers"},{"location":"v3/plugin-managers/#plugin-managers","text":"It can be useful to compose a plugin manager from which you can retrieve hydrators; in fact, Zend\\Hydrator\\DelegatingHydrator does exactly that! With such a manager, you can retrieve instances using short names, or instances that have dependencies on other services, without needing to know the details of how that works. Examples of Hydrator plugin managers in real-world scenarios include: hydrating database result sets preparing API payloads","title":"Plugin Managers"},{"location":"v3/plugin-managers/#hydratorpluginmanagerinterface","text":"We provide two plugin manager implementations. Essentially, they only need to implement the PSR-11 ContainerInterface , but plugin managers in current versions of zend-servicemanager only implement it indirectly via the container-interop project. As such, we ship Zend\\Hydrator\\HydratorPluginManagerInterface , which simply extends the PSR-11 Psr\\Container\\ContainerInterface . Each of our implementations implement it.","title":"HydratorPluginManagerInterface"},{"location":"v3/plugin-managers/#hydratorpluginmanager","text":"If you have used zend-hydrator prior to version 3, you are likely already familiar with this class, as it has been the implementation we have shipped from initial versions. The HydratorPluginManager extends the zend-servicemanager AbstractPluginManager , and has the following behaviors: It will only return Zend\\Hydrator\\HydratorInterface instances. It defines short-name aliases for all shipped hydrators (the class name minus the namespace), in a variety of casing combinations. All but the DelegatingHydrator are defined as invokable services (meaning they can be instantiated without any constructor arguments). The DelegatingHydrator is configured as a factory-based service, mapping to the Zend\\Hydrator\\DelegatingHydratorFactory . No services are shared; a new instance is created each time you call get() .","title":"HydratorPluginManager"},{"location":"v3/plugin-managers/#standalonehydratorpluginmanager","text":"Zend\\Hydrator\\StandaloneHydratorPluginManager provides an implementation that has no dependencies on other libraries. It can only load the hydrators shipped with zend-hydrator .","title":"StandaloneHydratorPluginManager"},{"location":"v3/plugin-managers/#hydratormanager-alias","text":"Zend\\Hydrator\\ConfigManager defines an alias service, HydratorManager . That service will point to Zend\\Hydrator\\HydratorPluginManager if zend-servicemanager is installed, and Zend\\Hydrator\\StandaloneHydratorPluginManager otherwise.","title":"HydratorManager alias"},{"location":"v3/plugin-managers/#custom-plugin-managers","text":"If you do not want to use zend-servicemanager, but want a plugin manager that is customizable, or at least capable of loading the hydrators you have defined for your application, you should write a custom implementation of Zend\\Hydrator\\HydratorPluginManagerInterface , and wire it to the HydratorManager service, and/or one of the existing service names. As an example, if you want a configurable solution that uses factories, and want those factories capable of pulling application-level dependencies, you might do something like the following: // In src/YourApplication/CustomHydratorPluginManager.php: namespace YourApplication; use Psr\\Container\\NotFoundExceptionInterface; use Psr\\Container\\ContainerInterface; use RuntimeException; use Zend\\Hydrator\\HydratorInterface; use Zend\\Hydrator\\HydratorPluginManagerInterface; use Zend\\Hydrator\\StandaloneHydratorPluginManager; class CustomHydratorPluginManager implements HydratorPluginManagerInterface { /** @var ContainerInterface */ private $appContainer; /** @var StandaloneHydratorPluginManager */ private $defaults; /** @var array<string, string|callable> */ private $factories = []; public function __construct(ContainerInterface $appContainer) { $this->appContainer = $appContainer; $this->defaults = new StandaloneHydratorPluginManager(); } /** * {@inheritDoc} */ public function get($id) : HydratorInterface { if (! isset($this->factories[$id]) && ! $this->defaults->has($id)) { $message = sprintf('Hydrator service %s not found', $id); throw new class($message) extends RuntimeException implements NotFoundExceptionInterface {}; } // Default was requested; fallback to standalone container if (! isset($this->factories[$id])) { return $this->defaults->get($id); } $factory = $this->factories[$id]; if (is_string($factory)) { $this->factories[$id] = $factory = new $factory(); } return $factory($this->appContainer, $id); } public function has($id) : bool { return isset($this->factories[$id]) || $this->defaults->has($id); } public function setFactoryClass(string $name, string $factory) : void { $this->factories[$name] = $factory; } public function setFactory(string $name, callable $factory) : void { $this->factories[$name] = $factory; } } // In src/YourApplication/CustomHydratorPluginManagerFactory.php: namespace YourApplication; use Psr\\Container\\ContainerInterface; class CustomHydratorPluginManagerFactory { public function __invoke(ContainerInterface $container) : CustomHydratorPluginManager { $config = $container->has('config') ? $container->get('config') : []; $config = $config['hydrators']['factories'] ?? []; $manager = new CustomHydratorPluginManager($this); if ([] !== $config) { $this->configureManager($manager, $config); } return $manager; } /** * @param array<string, string|callable> $config */ private function configureManager(CustomHydratorPluginManager $manager, array $config) : void { foreach ($config as $name => $factory) { is_string($factory) ? $manager->setFactoryClass($name, $factory) : $manager->setFactory($name, $factory); } } } // in config/autoload/hydrators.global.php or similar: return [ 'dependencies' => [ 'aliases' => [ 'HydratorManager' => \\YourApplication\\CustomHydratorPluginManager::class, ], 'factories' => [ \\YourApplication\\CustomHydratorPluginManager::class => \\YourApplication\\CustomHydratorPluginManagerFactory::class ], ], 'hydrators' => [ 'factories' => [ \\Blog\\PostHydrator::class => \\Blog\\PostHydratorFactory::class, \\News\\ItemHydrator::class => \\News\\ItemHydratorFactory::class, // etc. ], ], ];","title":"Custom plugin managers"},{"location":"v3/quick-start/","text":"zend-hydrator Hydration is the act of populating an object from a set of data. zend-hydrator is a simple component to provide mechanisms both for hydrating objects, as well as extracting data sets from them. The component consists of interfaces, and several implementations for common use cases. Base Interfaces ExtractionInterface namespace Zend\\Hydrator; interface ExtractionInterface { /** * Extract values from an object * * @return mixed[] */ public function extract(object $object) : array; } HydrationInterface namespace Zend\\Hydrator; interface HydrationInterface { /** * Hydrate $object with the provided $data. * * @param mixed[] $data * @return object The implementation should return an object of any type. * By purposely omitting the return type from the signature, * implementations may choose to specify a more specific type. */ public function hydrate(array $data, object $object); } HydratorInterface namespace Zend\\Hydrator; interface HydratorInterface extends ExtractionInterface, HydrationInterface { } Usage Usage involves instantiating the hydrator, and then passing information to it. use Zend\\Hydrator; $hydrator = new Hydrator\\ArraySerializableHydrator(); // To hydrate an object from values in an array: $object = $hydrator->hydrate($data, new ArrayObject()); // or, going the other way and extracting the values from an object as an array: $data = $hydrator->extract($object); Available Implementations Zend\\Hydrator\\ArraySerializableHydrator Follows the definition of ArrayObject . Objects must implement either the exchangeArray() or populate() methods to support hydration, and the getArrayCopy() method to support extraction. Zend\\Hydrator\\ClassMethodsHydrator Any data key matching a setter method will be called in order to hydrate; any method matching a getter method will be called for extraction, according to the following rules: is*() , has*() , and get*() methods will be extracted, and the method prefix will be removed from the property name. set*() methods will be used when hydrating properties. Zend\\Hydrator\\DelegatingHydrator Composes a hydrator locator, and will delegate hydrate() and extract() calls to the appropriate one based upon the class name of the object being operated on. // Instantiate each hydrator you wish to delegate to $albumHydrator = new Zend\\Hydrator\\ClassMethodsHydrator(); $artistHydrator = new Zend\\Hydrator\\ClassMethodsHydrator(); // Map the entity class name to the hydrator using the HydratorPluginManager. // In this case we have two entity classes, \"Album\" and \"Artist\". $hydrators = new Zend\\Hydrator\\HydratorPluginManager; $hydrators->setService('Album', $albumHydrator); $hydrators->setService('Artist', $artistHydrator); // Create the DelegatingHydrator and tell it to use our configured hydrator locator $delegating = new Zend\\Hydrator\\DelegatingHydrator($hydrators); // Now we can use $delegating to hydrate or extract any supported object $array = $delegating->extract(new Artist()); $artist = $delegating->hydrate($data, new Artist()); Zend\\Hydrator\\ObjectPropertyHydrator Any data key matching a publicly accessible property will be hydrated; any public properties will be used for extraction. Zend\\Hydrator\\ReflectionHydrator Similar to the ObjectPropertyHydrator , but uses PHP's reflection API to hydrate or extract properties of any visibility. Any data key matching an existing property will be hydrated; any existing properties will be used for extraction.","title":"Quick Start"},{"location":"v3/quick-start/#zend-hydrator","text":"Hydration is the act of populating an object from a set of data. zend-hydrator is a simple component to provide mechanisms both for hydrating objects, as well as extracting data sets from them. The component consists of interfaces, and several implementations for common use cases.","title":"zend-hydrator"},{"location":"v3/quick-start/#base-interfaces","text":"","title":"Base Interfaces"},{"location":"v3/quick-start/#usage","text":"Usage involves instantiating the hydrator, and then passing information to it. use Zend\\Hydrator; $hydrator = new Hydrator\\ArraySerializableHydrator(); // To hydrate an object from values in an array: $object = $hydrator->hydrate($data, new ArrayObject()); // or, going the other way and extracting the values from an object as an array: $data = $hydrator->extract($object);","title":"Usage"},{"location":"v3/quick-start/#available-implementations","text":"","title":"Available Implementations"},{"location":"v3/strategy/","text":"Zend\\Hydrator\\Strategy You can compose Zend\\Hydrator\\Strategy\\StrategyInterface instances in any of the hydrators to manipulate the way they behave on extract() and hydrate() for specific key/value pairs. The interface offers the following definitions: namespace Zend\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @param null|object $object (optional) The original object for context. * @return mixed Returns the value that should be extracted. */ public function extract($value, ?object $object = null); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @param null|array $data (optional) The original data for context. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value, ?array $data = null); } This interface is similar to what the Zend\\Hydrator\\ExtractionInterface and Zend\\Hydrator\\HydrationInterface provide; the reason is that strategies provide a proxy implementation for hydrate() and extract() on individual values. For this reason, their return types are listed as mixed, versus as array and object , respectively. Adding strategies to the hydrators This package provides the interface Zend\\Hydrator\\Strategy\\StrategyEnabledInterface . Hydrators can implement this interface, and then call on its getStrategy() method in order to extract or hydrate individual values. The interface has the following definition: namespace Zend\\Hydrator\\Strategy; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. */ public function addStrategy(string $name, StrategyInterface $strategy) : void; /** * Gets the strategy with the given name. */ public function getStrategy(string $name) : StrategyInterface; /** * Checks if the strategy with the given name exists. */ public function hasStrategy(string $name) : bool; /** * Removes the strategy with the given name. */ public function removeStrategy(string $name) : void; } We provide a default implementation of the interface as part of Zend\\Hydrator\\AbstractHydrator ; it uses an array property to store and retrieve strategies by name when extracting and hydrating values. Since all shipped hydrators are based on AbstractHydrator , they share these capabilities. Additionally, the functionality that consumes strategies within AbstractHydrator also contains checks if a naming strategy is composed, and, if present, will use it to translate the property name prior to looking up a strategy for it. Available implementations Zend\\Hydrator\\Strategy\\BooleanStrategy This strategy converts values into Booleans and vice versa. It expects two arguments at the constructor, which are used to define value maps for true and false . Zend\\Hydrator\\Strategy\\ClosureStrategy This is a strategy that allows you to pass in options for: hydrate , a callback to be called when hydrating a value, and extract , a callback to be called when extracting a value. Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy DateTimeFormatterStrategy provides bidirectional conversion between strings and DateTime instances. The input and output formats can be provided as constructor arguments. The strategy allows DateTime formats that use ! to prepend the format, or | or + to append it; these ensure that, during hydration, the new DateTime instance created will set the time element accordingly. As a specific example, Y-m-d| will drop the time component, ensuring comparisons are based on a midnight time value. Starting in version 3.0, the constructor defines a third, optional argument, $dateTimeFallback . If enabled and hydration fails, the given string is parsed by the DateTime constructor, as demonstrated below: // Previous behavior: $strategy = new Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP'); $hydrated1 = $strategy->hydrate('2016-03-04 10:29:40.123456+01'); // Format is the same; returns DateTime instance $hydrated2 = $strategy->hydrate('2016-03-04 10:29:40+01'); // Format is different; value is not hydrated // Using new $dateTimeFallback flag; both values are hydrated: $strategy = new Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy('Y-m-d H:i:s.uP', null, true); $hydrated1 = $strategy->hydrate('2016-03-04 10:29:40.123456+01'); $hydrated2 = $strategy->hydrate('2016-03-04 10:29:40+01'); Zend\\Hydrator\\Strategy\\DefaultStrategy The DefaultStrategy simply proxies everything through, without performing any conversion of values. Zend\\Hydrator\\Strategy\\ExplodeStrategy This strategy is a wrapper around PHP's implode() and explode() functions. The delimiter and a limit can be provided to the constructor; the limit will only be used for extract operations. Zend\\Hydrator\\Strategy\\SerializableStrategy SerializableStrategy provides the functionality backing Zend\\Hydrator\\ArraySerializableHydrator . You can use it with custom implementations for Zend\\Serializer\\Adapter\\AdapterInterface if you want to as well. Zend\\Hydrator\\Strategy\\StrategyChain This strategy takes an array of StrategyInterface instances and iterates over them when performing extract() and hydrate() operations. Each operates on the return value of the previous, allowing complex operations based on smaller, single-purpose strategies. Writing custom strategies The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this->foo; } public function setFoo($foo) { $this->foo = $foo; } public function getBar() { return $this->bar; } public function setBar($bar) { $this->bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo->setFoo('bar'); $foo->setBar('foo'); $hydrator = new ClassMethodsHydrator(); $hydrator->addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator->extract($foo); // array(2) { // [\"foo\"]=> // string(3) \"one\" // [\"bar\"]=> // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator->hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=> // string(3) \"bar\" // [\"bar\":protected]=> // string(3) \"foo\" // }","title":"Strategies"},{"location":"v3/strategy/#zend92hydrator92strategy","text":"You can compose Zend\\Hydrator\\Strategy\\StrategyInterface instances in any of the hydrators to manipulate the way they behave on extract() and hydrate() for specific key/value pairs. The interface offers the following definitions: namespace Zend\\Hydrator\\Strategy; interface StrategyInterface { /** * Converts the given value so that it can be extracted by the hydrator. * * @param mixed $value The original value. * @param null|object $object (optional) The original object for context. * @return mixed Returns the value that should be extracted. */ public function extract($value, ?object $object = null); /** * Converts the given value so that it can be hydrated by the hydrator. * * @param mixed $value The original value. * @param null|array $data (optional) The original data for context. * @return mixed Returns the value that should be hydrated. */ public function hydrate($value, ?array $data = null); } This interface is similar to what the Zend\\Hydrator\\ExtractionInterface and Zend\\Hydrator\\HydrationInterface provide; the reason is that strategies provide a proxy implementation for hydrate() and extract() on individual values. For this reason, their return types are listed as mixed, versus as array and object , respectively.","title":"Zend\\Hydrator\\Strategy"},{"location":"v3/strategy/#adding-strategies-to-the-hydrators","text":"This package provides the interface Zend\\Hydrator\\Strategy\\StrategyEnabledInterface . Hydrators can implement this interface, and then call on its getStrategy() method in order to extract or hydrate individual values. The interface has the following definition: namespace Zend\\Hydrator\\Strategy; interface StrategyEnabledInterface { /** * Adds the given strategy under the given name. */ public function addStrategy(string $name, StrategyInterface $strategy) : void; /** * Gets the strategy with the given name. */ public function getStrategy(string $name) : StrategyInterface; /** * Checks if the strategy with the given name exists. */ public function hasStrategy(string $name) : bool; /** * Removes the strategy with the given name. */ public function removeStrategy(string $name) : void; } We provide a default implementation of the interface as part of Zend\\Hydrator\\AbstractHydrator ; it uses an array property to store and retrieve strategies by name when extracting and hydrating values. Since all shipped hydrators are based on AbstractHydrator , they share these capabilities. Additionally, the functionality that consumes strategies within AbstractHydrator also contains checks if a naming strategy is composed, and, if present, will use it to translate the property name prior to looking up a strategy for it.","title":"Adding strategies to the hydrators"},{"location":"v3/strategy/#available-implementations","text":"","title":"Available implementations"},{"location":"v3/strategy/#writing-custom-strategies","text":"The following example, while not terribly useful, will provide you with the basics for writing your own strategies, as well as provide ideas as to where and when to use them. This strategy simply transforms the value for the defined key using str_rot13() during both the extract() and hydrate() operations: class Rot13Strategy implements StrategyInterface { public function extract($value) { return str_rot13($value); } public function hydrate($value) { return str_rot13($value); } } This is the example class with which we want to use the hydrator example: class Foo { protected $foo = null; protected $bar = null; public function getFoo() { return $this->foo; } public function setFoo($foo) { $this->foo = $foo; } public function getBar() { return $this->bar; } public function setBar($bar) { $this->bar = $bar; } } Now, we'll add the rot13 strategy to the method getFoo() and setFoo($foo) : $foo = new Foo(); $foo->setFoo('bar'); $foo->setBar('foo'); $hydrator = new ClassMethodsHydrator(); $hydrator->addStrategy('foo', new Rot13Strategy()); When you use the hydrator to extract an array for the object $foo , you'll receive the following: $extractedArray = $hydrator->extract($foo); // array(2) { // [\"foo\"]=> // string(3) \"one\" // [\"bar\"]=> // string(3) \"foo\" // } And when hydrating a new Foo instance: $hydrator->hydrate($extractedArray, $foo) // object(Foo)#2 (2) { // [\"foo\":protected]=> // string(3) \"bar\" // [\"bar\":protected]=> // string(3) \"foo\" // }","title":"Writing custom strategies"},{"location":"v3/naming-strategy/composite-naming-strategy/","text":"CompositeNamingStrategy Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction. Basic Usage When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar' ]); $underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' => $mapStrategy, 'barBat' => $underscoreNamingStrategy, ]); $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $foo->bar = 123; $foo->barBat = 42; print_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar' ]); $underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo => bar mapping 'bar' => $mapStrategy, 'foo' => $mapStrategy, // Define both directions for the barBat => bar_bat mapping 'barBat' => $underscoreNamingStrategy, 'bar_bat' => $underscoreNamingStrategy, ]); $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $foo->bar = 123; $foo->barBat = 42; $array = $hydrator->extract($foo); print_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 ) print_r($array); // Array ( [foo] => 123 [bar_bat] => 42 ) $foo2 = new Foo(); $hydrator->hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )","title":"Composite"},{"location":"v3/naming-strategy/composite-naming-strategy/#compositenamingstrategy","text":"Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy allows you to specify which naming strategy should be used for each key encountered during hydration or extraction.","title":"CompositeNamingStrategy"},{"location":"v3/naming-strategy/composite-naming-strategy/#basic-usage","text":"When invoked, the following composite strategy will extract the property bar to the array key foo (using the MapNamingStrategy ), and the property barBat to the array key bar_bat (using the UnderscoreNamingStrategy ): class Foo { public $bar; public $barBat; } $mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar' ]); $underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ 'bar' => $mapStrategy, 'barBat' => $underscoreNamingStrategy, ]); $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $foo->bar = 123; $foo->barBat = 42; print_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 ) Unfortunately, the CompositeNamingStrategy can only be used for extraction as it will not know how to handle the keys necessary for hydration ( foo and bar_bat , respectively). To rectify this we have to cover the keys for both hydration and extraction in our composite strategy: class Foo { public $bar; public $barBat; } $mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([ 'foo' => 'bar' ]); $underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([ // Define both directions for the foo => bar mapping 'bar' => $mapStrategy, 'foo' => $mapStrategy, // Define both directions for the barBat => bar_bat mapping 'barBat' => $underscoreNamingStrategy, 'bar_bat' => $underscoreNamingStrategy, ]); $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $foo->bar = 123; $foo->barBat = 42; $array = $hydrator->extract($foo); print_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 ) print_r($array); // Array ( [foo] => 123 [bar_bat] => 42 ) $foo2 = new Foo(); $hydrator->hydrate($array, $foo2); print_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )","title":"Basic Usage"},{"location":"v3/naming-strategy/identity-naming-strategy/","text":"IdentityNamingStrategy Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction. Basic Usage $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy->hydrate('foo'); // outputs: foo echo $namingStrategy->extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator->hydrate(array('foo' => 123), $foo); print_r($foo); // Foo Object ( [foo] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 )","title":"Identity"},{"location":"v3/naming-strategy/identity-naming-strategy/#identitynamingstrategy","text":"Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy uses the keys provided to it for hydration and extraction.","title":"IdentityNamingStrategy"},{"location":"v3/naming-strategy/identity-naming-strategy/#basic-usage","text":"$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); echo $namingStrategy->hydrate('foo'); // outputs: foo echo $namingStrategy->extract('bar'); // outputs: bar This strategy can be used in hydrators as well: class Foo { public $foo; } $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy(); $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator->hydrate(array('foo' => 123), $foo); print_r($foo); // Foo Object ( [foo] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo] => 123 )","title":"Basic Usage"},{"location":"v3/naming-strategy/intro/","text":"Naming Strategies Sometimes, the representation of a property should not share the same name as the property itself. As an example, when serializing an object for a JSON payload, you may want to convert camelCase properties to underscore_separated properties, and vice versa when deserializing JSON to an object. To make that possible, zend-hydrator provides naming strategies . These are similar to strategies , but instead of operating on the value , they operate on the name . NamingStrategyInterface Naming strategies implement Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface : namespace Zend\\Hydrator\\NamingStrategy; /** * Allow property extraction / hydration for hydrator */ interface NamingStrategyInterface { /** * Converts the given name so that it can be extracted by the hydrator. * * @param null|mixed[] $data The original data for context. */ public function hydrate(string $name, ?array $data = null) : string; /** * Converts the given name so that it can be hydrated by the hydrator. * * @param null|object $object The original object for context. */ public function extract(string $name, ?object $object = null) : string; } Providing naming strategies Hydrators can indicate they will consume naming strategies, as well as allow registration of them, by implementing Zend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface : namespace Zend\\Hydrator\\NamingStrategy; interface NamingStrategyEnabledInterface { /** * Sets the naming strategy. */ public function setNamingStrategy(NamingStrategyInterface $strategy) : void; /** * Gets the naming strategy. */ public function getNamingStrategy() : NamingStrategyInterface; /** * Checks if a naming strategy exists. */ public function hasNamingStrategy() : bool; /** * Removes the naming strategy. */ public function removeNamingStrategy() : void; } We provide a default implementation of this interface within the Zend\\Hydrator\\AbstractHydrator definition. Its getNamingStrategy() will lazy-load an IdentityNamingStrategy if none has been previously registered. Since all shipped hydrators extend AbstractHydrator , they can consume naming strategies. Shipped naming strategies We provide the following naming strategies: CompositeNamingStrategy IdentityNamingStrategy MapNamingStrategy UnderscoreNamingStrategy","title":"Introduction"},{"location":"v3/naming-strategy/intro/#naming-strategies","text":"Sometimes, the representation of a property should not share the same name as the property itself. As an example, when serializing an object for a JSON payload, you may want to convert camelCase properties to underscore_separated properties, and vice versa when deserializing JSON to an object. To make that possible, zend-hydrator provides naming strategies . These are similar to strategies , but instead of operating on the value , they operate on the name .","title":"Naming Strategies"},{"location":"v3/naming-strategy/intro/#namingstrategyinterface","text":"Naming strategies implement Zend\\Hydrator\\NamingStrategy\\NamingStrategyInterface : namespace Zend\\Hydrator\\NamingStrategy; /** * Allow property extraction / hydration for hydrator */ interface NamingStrategyInterface { /** * Converts the given name so that it can be extracted by the hydrator. * * @param null|mixed[] $data The original data for context. */ public function hydrate(string $name, ?array $data = null) : string; /** * Converts the given name so that it can be hydrated by the hydrator. * * @param null|object $object The original object for context. */ public function extract(string $name, ?object $object = null) : string; }","title":"NamingStrategyInterface"},{"location":"v3/naming-strategy/intro/#providing-naming-strategies","text":"Hydrators can indicate they will consume naming strategies, as well as allow registration of them, by implementing Zend\\Hydrator\\NamingStrategy\\NamingStrategyEnabledInterface : namespace Zend\\Hydrator\\NamingStrategy; interface NamingStrategyEnabledInterface { /** * Sets the naming strategy. */ public function setNamingStrategy(NamingStrategyInterface $strategy) : void; /** * Gets the naming strategy. */ public function getNamingStrategy() : NamingStrategyInterface; /** * Checks if a naming strategy exists. */ public function hasNamingStrategy() : bool; /** * Removes the naming strategy. */ public function removeNamingStrategy() : void; } We provide a default implementation of this interface within the Zend\\Hydrator\\AbstractHydrator definition. Its getNamingStrategy() will lazy-load an IdentityNamingStrategy if none has been previously registered. Since all shipped hydrators extend AbstractHydrator , they can consume naming strategies.","title":"Providing naming strategies"},{"location":"v3/naming-strategy/intro/#shipped-naming-strategies","text":"We provide the following naming strategies: CompositeNamingStrategy IdentityNamingStrategy MapNamingStrategy UnderscoreNamingStrategy","title":"Shipped naming strategies"},{"location":"v3/naming-strategy/map-naming-strategy/","text":"MapNamingStrategy Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use both during extraction and hydration; the map will translate the key based on the direction: When a map is provided for hydration, but not extraction, the strategy will perform an array_flip on the hydration map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromHydrationMap(array $hydrationMap) : MapNamingStrategy . When a map is provided for extraction, but not hydration, the strategy will perform an array_flip on the extraction map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromExtractionMap(array $extractionMap) : MapNamingStrategy . When maps are provided for both extraction and hydration, the appropriate map will be used during extraction and hydration operations. You can create an instance with this behavior using MapNamingStrategy::createFromAsymmetricMap(array $extractionMap, array $hydrationStrategy) : MapNamingStrategy . Most of the time, you will want your maps symmetrical; as such, set either a hydration map or an extraction map, but not both. Creating maps Hydration map only $namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap( [ 'foo' => 'bar', 'baz' => 'bash' ] ); echo $namingStrategy->extract('bar'); // outputs: foo echo $namingStrategy->extract('bash'); // outputs: baz echo $namingStrategy->hydrate('foo'); // outputs: bar echo $namingStrategy->hydrate('baz'); // outputs: bash Extraction map only $namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromExtractionMap( null, // no hydration map [ 'foo' => 'bar', 'baz' => 'bash' ] ); echo $namingStrategy->extract('foo'); // outputs: bar echo $namingStrategy->extract('baz'); // outputs: bash echo $namingStrategy->hydrate('bar'); // outputs: foo echo $namingStrategy->hydrate('bash'); // outputs: baz Both hydration and extraction maps $namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromAsymmetricMap( [ 'foo' => 'bar', 'baz' => 'bash' ], [ 'is_bar' => 'foo', 'bashable' => 'baz', ] ); echo $namingStrategy->extract('foo'); // outputs: bar echo $namingStrategy->extract('baz'); // outputs: bash echo $namingStrategy->hydrate('is_bar'); // outputs: foo echo $namingStrategy->hydrate('bashable'); // outputs: baz Mapping keys for hydrators This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([ 'foo' => 'bar', 'baz' => 'bash', ]); $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator->hydrate(['foo' => 123], $foo); print_r($foo); // Foo Object ( [bar] => 123 ) print_r($hydrator->extract($foo)); // Array ( \"foo\" => 123 )","title":"Mapping"},{"location":"v3/naming-strategy/map-naming-strategy/#mapnamingstrategy","text":"Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy allows you to provide a map of keys to use both during extraction and hydration; the map will translate the key based on the direction: When a map is provided for hydration, but not extraction, the strategy will perform an array_flip on the hydration map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromHydrationMap(array $hydrationMap) : MapNamingStrategy . When a map is provided for extraction, but not hydration, the strategy will perform an array_flip on the extraction map when performing lookups. You can create an instance with this behavior using MapNamingStrategy::createFromExtractionMap(array $extractionMap) : MapNamingStrategy . When maps are provided for both extraction and hydration, the appropriate map will be used during extraction and hydration operations. You can create an instance with this behavior using MapNamingStrategy::createFromAsymmetricMap(array $extractionMap, array $hydrationStrategy) : MapNamingStrategy . Most of the time, you will want your maps symmetrical; as such, set either a hydration map or an extraction map, but not both.","title":"MapNamingStrategy"},{"location":"v3/naming-strategy/map-naming-strategy/#creating-maps","text":"","title":"Creating maps"},{"location":"v3/naming-strategy/map-naming-strategy/#mapping-keys-for-hydrators","text":"This strategy can be used in hydrators to dictate how keys should be mapped: class Foo { public $bar; } $namingStrategy = Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy::createFromHydrationMap([ 'foo' => 'bar', 'baz' => 'bash', ]); $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy($namingStrategy); $foo = new Foo(); $hydrator->hydrate(['foo' => 123], $foo); print_r($foo); // Foo Object ( [bar] => 123 ) print_r($hydrator->extract($foo)); // Array ( \"foo\" => 123 )","title":"Mapping keys for hydrators"},{"location":"v3/naming-strategy/underscore-naming-strategy/","text":"UnderscoreNamingStrategy Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa. Basic Usage $namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy->extract('foo_bar'); // outputs: foo_bar echo $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy->extract('FooBar'); // outputs: foo_bar echo $namingStrategy->hydrate('fooBar'); // outputs: fooBar echo $namingStrategy->hydrate('FooBar'); // outputs: fooBar echo $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator->hydrate(['foo_bar' => 123], $foo); print_r($foo); // Foo Object ( [fooBar] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )","title":"Underscore Mapping"},{"location":"v3/naming-strategy/underscore-naming-strategy/#underscorenamingstrategy","text":"Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g. fooBarBaz ) and vice versa.","title":"UnderscoreNamingStrategy"},{"location":"v3/naming-strategy/underscore-naming-strategy/#basic-usage","text":"$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy(); echo $namingStrategy->extract('foo_bar'); // outputs: foo_bar echo $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar echo $namingStrategy->extract('FooBar'); // outputs: foo_bar echo $namingStrategy->hydrate('fooBar'); // outputs: fooBar echo $namingStrategy->hydrate('FooBar'); // outputs: fooBar echo $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar This strategy can be used in hydrators to dictate how keys should be mapped. class Foo { public $fooBar; } $hydrator = new Zend\\Hydrator\\ObjectPropertyHydrator(); $hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy()); $foo = new Foo(); $hydrator->hydrate(['foo_bar' => 123], $foo); print_r($foo); // Foo Object ( [fooBar] => 123 ) print_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )","title":"Basic Usage"}]}